{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Document Useage: C++17 is required, O2 is suggested, g++ is needed since some builtin functions have been used Categories: math, date structure, graph theory, geometry, mixed Index: begin with 0, unless otherwise state Categories: Math , Data Structure , Graph Theory , String Note algorithm name end with S means simple and slow, Non-constant member variables are terminated with _ to distinguish local variables, std::move and std::forward are used for performance commom ideals Dynamic programming Bisection Binary lifting Blocking Divide and Conquer Meet in Middle Small to Large Venice Technique A few words Think twice, code once Talk is cheap, show me the code More is different","title":"Introduction"},{"location":"#document","text":"Useage: C++17 is required, O2 is suggested, g++ is needed since some builtin functions have been used Categories: math, date structure, graph theory, geometry, mixed Index: begin with 0, unless otherwise state Categories: Math , Data Structure , Graph Theory , String","title":"Document"},{"location":"#note","text":"algorithm name end with S means simple and slow, Non-constant member variables are terminated with _ to distinguish local variables, std::move and std::forward are used for performance","title":"Note"},{"location":"#commom-ideals","text":"Dynamic programming Bisection Binary lifting Blocking Divide and Conquer Meet in Middle Small to Large Venice Technique","title":"commom ideals"},{"location":"#a-few-words","text":"Think twice, code once Talk is cheap, show me the code More is different","title":"A few words"},{"location":"cn/","text":"\u6b64\u6587\u6863\u4ec5\u4e3a\u8865\u5145\uff0c\u8fd9\u91cc\u5c31\u653e\u4e00\u4e2a\u5927\u81f4\u76ee\u5f55\u548c\u4e00\u4e9b\u6838\u5fc3\u5185\u5bb9\u7684\u8bf4\u660e\uff08\u6709\u4e9b\u82f1\u6587\u8bf4\u592a\u9ebb\u70e6\uff09\uff0c\u53ef\u4ee5\u5728\u6211\u7684 cnblog \u91cc\u627e\u5230\u5f88\u591a\u6838\u5fc3\u4ee3\u7801\u7684\u539f\u7406 \u6587\u6863 \u4f7f\u7528\uff1a\u7f16\u8bd1\u5668\u9700\u652f\u6301 C++17\uff0c\u5f3a\u70c8\u5efa\u8bae\u5f00\u542f O2 \u4f18\u5316 \u5206\u7c7b\uff1a\u6570\u5b66\uff0c\u6570\u636e\u7ed3\u6784\uff0c\u5b57\u7b26\u4e32\uff0c\u56fe\u8bba\uff0c\u51e0\u4f55\uff0c\u6742\u7c7b \u7ea6\u5b9a\uff1a\u4ee5 S \u4e3a\u540e\u7f00\u7684\u7b97\u6cd5\u90fd\u662f \u6162\u4e14\u7b80\u5355 \u7684\u7b97\u6cd5\uff0c\uff1f\u8868\u793a\u6682\u672a\u5b9e\u73b0\u3002 \u4e0b\u6807\uff1a\u9ed8\u8ba4\u4ee5 0 \u5f00\u5934\uff0c\u76ee\u524d\u53ea\u6709 \u6811\u72b6\u6570\u7ec4\u548c\u4e00\u4e9b\u6811\u7b97\u6cd5 \u4e3a\u4e86\u65b9\u4fbf\u8d77\u89c1\u4ece 1 \u5f00\u5934\u3002 \u601d\u60f3 \u52a8\u6001\u89c4\u5212 \u4e8c\u5206 \u500d\u589e \u5206\u5757 \u5206\u6cbb \u6c34\u6da8\u8239\u9ad8 \u51b3\u7b56\u5355\u8c03\u6027\u4f18\u5316 Meet in Middle Small to Large \u6570\u5b66 \u57fa\u7840\u6a21\u5757\uff1aprimary.hpp \u6a21\u5feb\u901f\u5e42 \u5411\u4e0a\u53d6\u6574\u548c\u5411\u4e0b\u53d6\u6574 int128 \u8bfb\u5199\uff08\u5feb\u8bfb\uff0cint, long long \u4e5f\u53ef\u4ee5\u4f7f\u7528\uff09 \u4e8c\u8fdb\u5236\u5feb\u901f gcd\uff0c\u62d3\u5c55 gcd \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 CRT \u5e38\u89c4\u4e8c\u9879\u5f0f\u7cfb\u6570\u548c\u6a21\u4e8c\u9879\u5f0f\u7cfb\u6570\uff08\u5355\u4f8b\uff09 Lagrange \u63d2\u503c \u6a21\u81ea\u7136\u6570\u65b9\u5e42\u548c O(k) \u7b97\u6cd5 \u6a21 N \\times N \u77e9\u9635\u4e58\u6cd5\u7c7b\uff08\u7f13\u5b58\u4f18\u5316\uff09 MEX\uff08\u96c6\u5408\u4e2d\u4e0d\u51fa\u73b0\u7684\u6700\u5c0f\u7684\u81ea\u7136\u6570\uff09 \u5feb\u901f\u6392\u5e8f\uff08\u6ca1\u5e26\u968f\u673a\u9009\u62e9\uff0c\u522b\u7528\uff09 \u9884\u5904\u7406\u6700\u5c0f\u7d20\u56e0\u5b50 BerlekampMassey\uff08\u7528\u6765\u627e\u6700\u77ed\u9012\u63a8\u516c\u5f0f\uff09 BitCount \u6bd4 __builtin_popcount \u66f4\u5feb\u7684\u505a\u6cd5 bitCountTable \u67e5\u8868\u6cd5\u5f88\u5feb\uff0c\u4f46\u662f\u7b2c\u4e00\u6b21\u4f1a\u5f88\u6162\uff0c\u56e0\u6b64 __builtin_popcount \u5e76\u672a\u91c7\u7528\u6b64\u65b9\u6cd5 int bitCountTable(unsigned n) { static int table[256] = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, }; return table[n & 0xff] + table[(n >> 8) & 0xff] + table[(n >> 16) & 0xff] + table[n >> 24]; } __builtin_popcount \u6211\u731c\u6d4b\u5b9e\u73b0\u4e3a\u5982\u4e0b\uff08\u5b9e\u6d4b\u8fd0\u884c\u65f6\u95f4\u4e00\u81f4\uff09 int bitCount0(unsigned x) { static const unsigned mask = 0x01010101; return ((mask & x) + (mask & (x >> 1)) + (mask & (x >> 2)) + (mask & (x >> 3)) + (mask & (x >> 4)) + (mask & (x >> 5)) + (mask & (x >> 6)) + (mask & (x >> 7))) % 255; } \u4e5f\u5c31\u662f\u8bf4\u6bcf\u9694 8 \u4e2a bit \u4e00\u4e2a 1\uff0c\u7136\u540e\u4e00\u4e2a\u4e2a\u7684\u52a0\u4e0a\u53bb\uff08\u5206\u6210 4 \u7ec4\uff09\uff0c\u6700\u540e\u8fd9 4 \u7ec4\u7684\u7b54\u6848\u52a0\u8d77\u6765\u7b49\u4ef7\u4e8e\u6a21 255 \u6ce8\u610f\u5230\u5176\u5b9e\u5bf9\u4e8e unsigned\uff0c\u7ed3\u679c\u7684\u6700\u5927\u503c\u4e3a 32\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u7528 6 \u4e2abit \u5c31\u80fd\u5b58\u4e0b\u6240\u6709\u7684\u7b54\u6848\uff0c\u4e8e\u662f\u6211\u4eec\u5176\u5b9e\u53ef\u4ee5\u6bcf\u9694 6 \u4e2a bit \u4e00\u4e2a 1\uff08\u6240\u4ee5\u7528 8 \u8fdb\u5236\u66f4\u5408\u7406\uff09\uff0c\u7136\u540e\u540c\u6837\u4e00\u4e2a\u4e2a\u7684\u52a0\uff08\u5206\u6210 6 \u7ec4\uff09\uff0c\u6700\u540e\u8fd9 6 \u7ec4\u52a0\u8d77\u6765\u7b49\u4ef7\u4e8e\u6a21 63 int bitCount1(unsigned x) { static const unsigned mask = 010101010101; return ((mask & x) + (mask & (x >> 1)) + (mask & (x >> 2)) + (mask & (x >> 3)) + (mask & (x >> 4)) + (mask & (x >> 5))) % 63; } \u4f46\u5176\u5b9e\u53ef\u4ee5\u66f4\u8fd1\u4e00\u6b65\uff0c\u6211\u4eec\u53ef\u4ee5\u5148 3 \u4e2a bit \u4e00\u4e2a 1\uff0c\u7136\u540e\u628a 2 \u4e2a 3bit \u5408\u6210\u4e00\u4e2a 6 bit int bitCount2(unsigned x) { static const unsigned mask = 011111111111; unsigned tmp = (mask & x) + (mask & (x >> 1)) + (mask & (x >> 2)); return ((tmp + (tmp >> 3)) & 030707070707) % 63; } \u7136\u540e\u53ef\u4ee5\u518d\u8fd1\u4e00\u6b65\uff0c\u6ce8\u610f\u5230 (a00)_2 - (a0)_2 - (a)_2 = a , \u6240\u4ee5 (abc)_2 - (ab)_2 - (a) = a + b + c \uff0c\u8fd9\u6837\u53ef\u4ee5\u7701\u4e00\u6b21 & \u64cd\u4f5c int bitCount(unsigned n) { unsigned tmp = n - ((n >> 1) & 033333333333) - ((n >> 2) & 011111111111); return ((tmp + (tmp >> 3)) & 030707070707) % 63; } \u5f53\u7136\u4e86\u6211\u4eec\u8fd8\u9700\u8981\u5904\u7406 unsigned long long\uff0c\u505a\u6cd5\u540c\u7406\uff0c\u5bf9\u4e8e Table \u6cd5\u53ef\u4ee5\u9009\u53d6\u66f4\u5927\u7684 table\uff0c\u6216\u8005\u76f4\u63a5\u5957\u7528\u4e24\u6b21 bitCountTable\uff0c\u800c\u5bf9\u4e8e bitCount \u6b64\u65f6\u5c31\u5e94\u8be5\u9009\u62e9 4/8 bit \u4e00\u6b21\u7684\u505a\u6cd5\u4e86 int bitCountTableLL(unsigned long long n) { return bitCountTable(n >> 32) + bitCountTable(n & 0xffffffff); } int bitCountll(unsigned long long n) { unsigned long long tmp = n - ((n >> 1) & 0x7777777777777777ULL) - ((n >> 2) & 0x3333333333333333ULL) - ((n >> 3) & 0x1111111111111111ULL); return ((tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL) % 255; } mod.hpp MInt: \u8fd9\u4e2a\u662f\u7c7b\u6a21\u677f ModInt ModLL FFT.hpp NTT.hpp FMT.hpp \u5feb\u901f Mobius \u53d8\u6362\uff0c\u53eb\u8fd9\u4e2a\u540d\u5b57\u662f\u56e0\u4e3a\u8ddf\u6570\u8bba\u51fd\u6570\u7684 Mobius \u53d8\u6362\u5f62\u5f0f\u4e0a\u4e00\u81f4 \u521d\u7b49\u6570\u8bba\uff1anumberTheory.hpp \u5feb\u901f O(n \\log \\log n) \u7d20\u6570\u7b5b\u548c\u6162\u901f\u7ebf\u6027\u7b5b \u5feb\u901f\u8ba1\u7b97 \\pi(x) \u5feb\u901f\u8ba1\u7b97\u7b2c n \u4e2a\u7d20\u6570\uff08\u4ece 1 \u5f00\u59cb\u6807\u53f7\uff0cp[1] = 2\uff0cp[0] \u65e0\u610f\u4e49\uff09 Euler \u7ebf\u6027\u7b5b Mobius \u7ebf\u6027\u7b5b \u62d3\u5c55\u6b27\u62c9\u5b9a\u7406\uff08\u7ed3\u8bba\u5341\u5206\u7b80\u5355\uff0c\u8bc1\u660e\u9700\u8981\u5206\u89e3\u7d20\u56e0\u5f0f\uff09 min_25 \u7b5b O(n^{\\frac{2}{3}}) \u7b97\u6cd5\u6c42 Euler \u51fd\u6570\u524d\u7f00\u548c\uff0cMobius\uff08\u7edd\u5bf9\u503c\uff09\u524d\u7f00\u548c\uff08\u5185\u542b \u6574\u9664\u5206\u5757\uff09 \u6700\u5c0f\u7d20\u56e0\u5b50\u7ebf\u6027\u7b5b \u9884\u5904\u7406\u7d20\u56e0\u5b50\u4e2a\u6570\uff08\u7b97\u91cd/\u4e0d\u7b97\u91cd\uff09 \u7d20\u56e0\u5b50\u5206\u89e3\uff08\u7b97\u91cd/\u4e0d\u7b97\u91cd\uff09 \u6c42\u539f\u6839 \u5927\u7d20\u6570 Miller-Rabin \u6982\u7387\u5224\u522b\u6cd5 Pollard-Pho \u5927\u6574\u6570\u6700\u5927\u6700\u5c0f\u7d20\u56e0\u5b50\u5206\u89e3 \u6a21\u7d20\u6570\u53d6 log\uff08BabyStepGaintStep\uff09 \u6a21\u7d20\u6570\u5f00\u6839\u53f7 O(log^2 p) \u6a21\u7d20\u6570\u5f00\u6839\u53f7 O(log p) \u7684 Cipolla \u7b97\u6cd5 \u6a21\u5076\u7d20\u6570\u5e42\u5f00\u6839\u53f7\uff1f \u6a21\u5947\u7d20\u6570\u5e42\u5f00\u6839\u53f7\uff1f \u6a21\u4efb\u610f\u6570\u5f00\u6839\u53f7\uff08\u5148\u56e0\u5f0f\u5206\u89e3\uff0c\u770b\u4f5c\u6a21\u7d20\u6570\u65b9\u5f00\u6839\u53f7\uff0c\u518d CRT \u6574\u5408\uff09\uff1f BigInt \u6742\u7c7b \u5feb\u901f\u66b4\u529b n \u4e2a\u96c6\u5408\u4e2d\u9009 k \u4e2a\uff0c\u4e8c\u8fdb\u5236\u4e3a 1 \u7684\u8868\u793a\u9009\u62e9 KnuthShuffle uniformChoose Fibonacci \u6570\u5217 floorSum\uff1a \\displaystyle \\sum_{i = 0}^{n - 1} \\lfloor \\frac{a \\cdot i + b}{m} \\rfloor sumNum\uff1a \\displaystyle \\sum_{\\sum c_i x_i = m} \\frac{(\\sum x_i)!}{\\prod (x_i !)} decInc: \u6bcf\u6b21\u53ef\u9009\u62e9 n \u51cf\u4e00 \u6216 m \u52a0\u4e00\uff0c\u4f7f\u5f97 m \u662f n \u7684\u500d\u6570\u7684\u6700\u5c0f\u6b21\u6570 Gauss \u6d88\u5143\u6cd5\u6d6e\u70b9\u6570\u7248 \u6a21 Gauss \u6d88\u5143\u6cd5 \u7ebf\u6027\u89c4\u5212\u4e4b\u5355\u7eaf\u5f62\u7b97\u6cd5 \u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5 O(n^{\\log_2 3}) \u7684 Karatsuba \u7b97\u6cd5\uff08\u5305\u62ec\u5e76\u884c\u7248\uff09 \u7ebf\u6027\u89c4\u5212 FirstInRange\uff1a\u6c42\u6700\u5c0f\u7684 x \u4f7f\u5f97 l \\leq a x \\mod m \\leq r \u3002\u7c7b\u4f3c exgcd \u7684\u5904\u7406\uff1a\u6c42\u6700\u5c0f\u975e\u8d1f\u6574\u6570 x \u4f7f\u5f97 l \\leq ax - m y \\leq r \u7b49\u4ef7\u4e8e l \\leq (az - m)y - a(yz - x) \\leq r \uff0c\u6ce8\u610f\u5230\u6211\u4eec\u8981\u59cb\u7ec8\u4fdd\u6301 a < m \uff0c\u56e0\u6b64\u5f53 2a > m \u65f6\u9700\u8981\u7279\u5224\u4e00\u4e0b\u3002\u8f6c\u5316\u6210 m - r \\leq (m - a) x - m(x - y - 1) \\leq m - l KnuthShuffle \u548c uniformChoose \u539f\u7406 \u6211\u4eec\u4ece\u540e\u5f80\u524d\u641e( a[x] = x )\uff0c\u5047\u8bbe\u5f53\u524d\u8981\u5904\u7406 i \u4f4d\u7f6e\uff0c\u90a3\u4e48 i \u4f4d\u7f6e\u524d\u7684\u4f4d\u7f6e\u4e0d\u53ef\u80fd\u6709\u4ea4\u6362\u7684\u60c5\u51b5\uff0c\u5373\u4e0d\u53ef\u80fd j < k \\leq i , a[j] = k \u6216\u8005 a[k] = j , \u8fd9\u662f\u56e0\u4e3a\u4e00\u4f46\u67d0\u4e2a\u4f4d\u7f6e\u88ab\u6362\u5230\u540e\u9762\u4e4b\u540e\u5c31\u4e0d\u4f1a\u518d\u53d8\u5316\u4e86\u3002 \u6ce8\u610f\u5230\u4e0a\u9762\u8fd9\u4e00\u70b9\uff0c\u5c31\u53ef\u4ee5\u53d1\u73b0 i \u540e\u9762\u7684\u6bcf\u4e2a\u4f4d\u7f6e\u6bcf\u4e2a\u6570\u51fa\u73b0\u7684\u6982\u7387\u5747\u7b49\uff0c\u4e14\u5bf9\u4e8e j \\leq i , a[j] = j \u7684\u6982\u7387\u4e3a \\frac{i}{n} \uff0c\u4e3a i + 1, i + 2, \\cdots, n \u7684\u6982\u7387\u4e3a \\frac{1}{n} \u6240\u4ee5 n \u6b65\u4e4b\u540e\u6240\u6709\u4f4d\u7f6e\u6982\u7387\u90fd\u4e3a \\frac{1}{n} \u6839\u636e\u4e0a\u8ff0\u63a8\u7406\uff0c\u6211\u4eec\u5728 n \u4e2a\u6570\u4e2d\u7b49\u6982\u7387\u7684\u9009\u53d6\u4e0d\u540c\u7684 m \u4e2a\u6570\uff0c\u663e\u7136\u53ea\u9700\u8981\u641e m \u6b65\uff0c\u540e\u9762\u7684 m \u4e2a\u6570\u4e3a\u7b54\u6848\u3002\u7136\u540e\u9ed8\u8ba4 a[i] = i \uff0c\u6240\u4ee5\u7528\u4e00\u4e2a map \u4fdd\u5b58\u6240\u6709 a[i] \u4e0d\u4e00\u5b9a\u4e3a i \u7684\u4f4d\u7f6e\u7684\u503c \u591a\u9879\u5f0f\uff08 \u591a\u9879\u5f0f\u5168\u5bb6\u6876 \u5df2\u5168\u90e8 AC\uff09 \u4ec5\u5305\u542b\u4e58\u6cd5\u7684\u56db\u5927\u591a\u9879\u5f0f\u5e95\u5c42\u57fa\u7c7b\u5206\u522b\u4e3a\uff1aPolyBaseNTT, PolyBaseMFT3(\u5f03\u7528\uff0c\u88ab\u540e\u9762\u4e24\u4e2a\u6dd8\u6c70\u4e86), PolyBaseMFT4, PolyBaseFFT PolyBaseNTT\uff1a\u57fa\u4e8e\u56fa\u5b9a\u7684 NTT-friendly\uff08\u539f\u6839\u4e00\u822c\u4e3a 3\uff09\u6a21\u6570\u5feb\u901f\u6570\u8bba\u53d8\u5316\uff08\u770b\u5177\u4f53\u9898\u76ee\uff0c\u4e00\u822c\u4e3a 998244353\uff09 PolyBaseMFT3\uff1a\u57fa\u4e8e\u4e09\u4e2a\u56fa\u5b9a\u7684 NTT-friendly \u4e14\u539f\u6839\u4e3a 3 \u7684\u4e09\u6a21\u6570\uff08469762049, 998244353, 1004535809\uff09\uff0c\u5229\u7528 crt \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\uff08\u5df2\u88ab\u6dd8\u6c70\uff0c\u8bf7\u52ff\u4f7f\u7528\uff09 PolyBaseMFT4\uff1a\u57fa\u4e8e\u56db\u4e2a\u56fa\u5b9a\u7684 NTT-friendly \u4e14\u539f\u6839\u4e3a 3 \u7684\u56db\u6a21\u6570\uff08595591169, 645922817, 897581057, 998244353\uff09\uff0c\u5229\u7528 crt \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5 PolyBaseFFT\uff1a\u57fa\u4e8e FFT \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\uff08\u9700\u8981\u6ce8\u610f\u7cbe\u5ea6\uff09 \u901a\u8fc7\u6a21\u677f\u7ee7\u627f\u62d3\u5c55\u5f97\u5230\u5168\u9762\u7684\u591a\u9879\u5f0f\u7c7b Poly (\u52a0\u51cf\u4e58\u9664\u4f59\uff0c\u8f6c\u7f6e\u4e58\u6cd5\uff0c\u6c42\u5bfc\uff0c\u79ef\u5206\uff0c\u6307\u6570\uff0c\u5bf9\u6570\uff0c\u6c42\u9006\uff0c\u5f00\u65b9\uff0c\u4e00\u70b9\u6c42\u503c\uff0c\u591a\u70b9\u6c42\u503c\uff0c\u5feb\u901f\u5e42\u6a21\uff0c\u5185\u79ef\uff0c\u4e00\u4e2a\u9996\u4e00\u591a\u9879\u5f0f\u7684\u6b21\u65b9\u6a21 x^n \u5148\u53d6\u5bf9\u6570\u4e58\u4ee5\u6b21\u6570\u518d\u53d6\u6307\u6570\u5f97\u5230\uff0c\u4e09\u89d2\u51fd\u6570\uff0c\u53cd\u4e09\u89d2\u51fd\u6570)\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5b66\u5230\u4e86\u5f88\u591a\u4e1c\u897f \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a O(n \\log^2 n) \u8ba1\u7b97 \\sum_{i = 1}^n \\frac{a_i}{1 - b_i} \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a O(k \\log k \\log n) \u6c42 k \u9636\u5e38\u7cfb\u6570\u9012\u63a8\u516c\u5f0f\u7684\u7b2c n \u9879 \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a\u6a21\u81ea\u7136\u6570\u65b9\u5e42\u548c O(k \\log k) \u5f97\u5230\u524d k \u4e2a\u7b54\u6848 \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1aLagrange \u63d2\u503c\uff1a\u5148\u5206\u6cbb\u6c42 g(x) = \\prod(x - x_i) \uff0c\u518d\u6c42 g'(x) \u5728 x \u5904\u7684\u591a\u70b9\u6c42\u503c\uff0c\u518d\u5206\u6cbb\u5373\u53ef\u3002 \u6c42\u9636\u4e58 n! \\mod p \uff1a\u57fa\u4e8e\u591a\u70b9\u6c42\u503c O(\\sqrt{n} \\log^2 n) \u6c42 \\sqrt{n} \u4e2a\u70b9\u4e4b\u540e\u66b4\u529b \u6c42\u9636\u4e58 n! \\mod p \uff1amin_25 \u7528\u70b9\u6c42\u70b9 O(\\sqrt{n} \\log n) \u6c42 \\sqrt{n} \u4e2a\u70b9\u4e4b\u540e\u66b4\u529b \u65e0\u8fd0\u7b97\u7684\u591a\u9879\u5f0f\u5e95\u5c42\u57fa\u7c7b\uff1aPolyBase\uff08standard \u5728\u53d6\u4f59\u65f6\uff0c\u7279\u522b\u91cd\u8981\u4e0d\u53ef\u7701\u7565\uff09 \u4f7f\u7528\u51c6\u5219 \u591a\u9879\u5f0f\u9879\u6570 N < 4 \\cdot 10^6 M \u8981\u662f\u8d85\u4e86 int\uff0c\u90a3\u5c31\u53ea\u80fd\u7528 ModLL \u7248\u672c 4 \u6a21\u6570 Poly \u5426\u5219\uff0c\u8981\u662f M \u4e0d\u56fa\u5b9a\u5c31\u7528\u4f7f\u7528 ModInt \u7684 FFT \u7248 Poly \u5426\u5219\uff0c\u5f53 M \u4e3a\u56fa\u5b9a\u7684 NTT-friendly \u7d20\u6570\u65f6\uff0c\u4f7f\u7528 NTT \u7248 Poly \u5426\u5219\uff0c\u4f7f\u7528 MInt \u7684 FFT \u7248 Poly \u6781\u7b80\u7248\u591a\u9879\u5f0f\u6a21\u677f\uff08polyS\uff09 \u7531\u4e8e\u591a\u9879\u5f0f\u6a21\u677f\u4e00\u76f4\u6269\u5c55\uff0c\u52a8\u5219 1000+ \u884c\uff0c\u5b9e\u5728\u6709\u70b9\u641e\uff0c\u6240\u4ee5\u5c31\u641e\u4e86\u4e00\u4e2a\u6781\u7b80\u7248\u7684\u3002 4 \u6b21 FFT \u539f\u7406 \u6211\u4eec\u672c\u6765\u8981\u6c42 A \\dot B \uff0c\u7136\u540e\u6211\u4eec\u628a\u5b83\u62c6\u6210 A = A_1 + 2^{d} A_2, B = B_1 + 2^d B_2 \uff0c\u90a3\u4e48 AB = A_1 B_1 + (A_1 B_2 + A_2 B_1) 2^d + A_2 B_2 2^{2d} \u4e8e\u662f\u6211\u4eec\u53ea\u9700\u8ba1\u7b97 (A_1 + i A_2)(B_1 + i B_2) \u548c (A_1 + i A_2)(B_1 - i B_2) \u5373\u53ef\uff0c\u4f46\u662f\u6ce8\u610f\u5230 dft((B_1 + i B_2))[j] = \\overline{dft((B_1 + i B_2))[n - j]} \u6240\u4ee5\u672c\u6765\u9700\u8981 5 \u6b21 FFT\uff0c\u73b0\u5728\u53ea\u9700\u8981 4 \u6b21\u5373\u53ef\u3002 \u5176\u5b9e\u672c\u8d28\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u53ea\u505a 3.5 \u6b21 FFT\uff0c\u56e0\u4e3a 2 \u6b21 dft \u6211\u4eec\u53ef\u4ee5\u5f97\u5230 A_1, A_2, B_1, B_2 \u7684 dft \u503c\uff0c\u7136\u540e\u6211\u4eec\u6700\u540e\u53ea\u9700 3 \u6b21\u5b9e\u6570\u7248 idft \u5373\u53ef\uff08\u7b97\u4f5c 1.5 \u6b21\uff09\uff01\u6240\u4ee5\u603b\u7684\u6765\u8bf4\u662f 3.5 \u6b21\u3002\u4f46\u662f\u5b9e\u73b0\u7684\u65f6\u5019\u4e5f\u6ca1\u529e\u6cd5\u641e 0.5 \u6b21\uff0c\u53ef\u60dc\u3002 min_25 \u7528\u70b9\u6c42\u70b9\u539f\u7406\uff08\u5176\u5b9e\u53ef\u4ee5\u7528\u4e0b\u964d\u5e42\u66f4\u7b80\u6d01\u7684\u5904\u7406\uff09 \u5b66\u4e60\u8d44\u6599\uff1a zzqsblog , bztMinamoto \u6211\u4eec\u4ee4 s = \\sqrt{n} \u7136\u540e \\displaystyle g_{s}(x) = \\sum_{i = 1}^{s}(x + i) \uff0c\u6211\u4eec\u60f3\u8981\u5f97\u5230 g_s(0), g_s(s), \\cdots g_s((s - 1)s) \u7684\u503c\u3002\u7136\u540e n! = \\prod_{i = 0}^{s - 1} g_s(i s) \\cdot \\prod_{i = s^2 + 1}^n i \u73b0\u5728\u5047\u8bbe\u6211\u4eec\u5df2\u7ecf\u5f97\u5230\u4e86 g_d(0), g_d(s), \\cdots g_d(d s) \u4e00\u4e2a d \u6b21\u591a\u9879\u5f0f\u7531\u5b83\u5728 d + 1 \u4e2a\u4e0d\u540c\u70b9\u7684\u53d6\u503c\u552f\u4e00\u51b3\u5b9a\uff08\u591a\u4e8e d + 1 \u4e2a\u70b9\u4e5f\u53ef\u4ee5\uff09 \u6211\u4eec\u5982\u4f55\u6c42 g_{d + 1}(0), g_{d + 1}(s), \\cdots g_{d + 1}((d + 1) s) \u6ce8\u610f\u5230 g_{d + 1}(x) = g_{d}(x) \\cdot (x + d + 1) \u5373\u53ef O(d) \u8ba1\u7b97\u51fa \u524d d + 1 \u4e2a\uff0c\u6700\u540e\u4e00\u4e2a\u76f4\u63a5\u66b4\u529b\u8ba1\u7b97\u5373\u53ef\u3002 \u6211\u4eec\u5982\u4f55\u6c42 g_{2d}(0), g_{2d}(s), \\cdots g_{2d}(2d s) \u540c\u6837\u6211\u4eec\u6ce8\u610f\u5230 g_{2d}(x) = g_{d}(x) \\cdot g_d(x + d) \u5982\u679c\u6211\u4eec\u8bbe h(i) = g_d(i s) \uff0c\uff08\u90a3\u4e48\u5f88\u5173\u952e\u7684\u4e00\u70b9 g_d(is + d) = g((d / s + i) s = h(d / s + i) \uff0c\u5367\u69fd\uff0c d / s \u5728\u6a21 p \u610f\u4e49\u4e0b\u5f97\u5230\u5c31\u53ef\u4ee5\u4e86\uff0c\u800c\u4e14\u80af\u5b9a\u5927\u4e8e d\uff0c\u5426\u5219\u77db\u76fe\uff01\uff09\u90a3\u4e48\u95ee\u9898\u5c31\u8f6c\u5316\u6210\u5982\u4f55\u6839\u636e\u4e00\u4e2a d \u6b21\u591a\u9879\u5f0f\u7684\u503c\uff1a h(0), h(1), \\cdots, h(d) \u6c42 h(d + 0), \\cdots h(d + d) \u4ee5\u53ca h(d / s + 0), \\cdots h(d / s + d) \u6211\u4eec\u4e0d\u59a8\u5bf9\u4e8e\u4efb\u610f\u7684\u7ed9\u5b9a\u7684 k > d \uff0c\u5148\u6c42\u51fa h(k + 0), h(k + 1), \\cdots h(k + d) \u6ce8\u610f\u5230\u6839\u636e Lagrange \u63d2\u503c\u591a\u9879\u5f0f \\begin{aligned} h(x) &= \\sum_{i = 0}^{d} h(i) \\prod_{j = 0, j \\neq i}^{d} \\frac{x - j}{i - j} \\\\ &= \\sum_{i = 0}^d (-1)^{d - i} h(i) \\binom{x}{i} \\binom{x - i - 1}{d - i} \\\\ &= \\left(\\prod_{i = x - d}^x i \\right) \\sum_{i = 0}^d \\frac{h(i)}{i!(d - i)!(-1)^{d - i}} \\cdot \\frac{1}{(x - i)} \\end{aligned} \u6ce8\u610f\u5230\u8fd9\u91cc\u7684\u5377\u79ef\u8ddf\u6211\u4eec\u666e\u901a\u7684\u5377\u79ef\u4e0d\u4e00\u81f4\uff0c\u5de6\u8fb9\u957f\u5ea6\u4e3a d + 1 \u7684\u591a\u9879\u5f0f\u4e58\u4ee5\u53f3\u8fb9\u957f\u5ea6\u4e3a 2d + 1 \u7684\u591a\u9879\u5f0f\uff0c\u7136\u540e\u6b21\u6570\u4e3a d, \\cdots 2d \u8fd9 d + 1 \u4f4d\u662f\u6709\u6548\u7684\u3002 \u4e0d\u80fd\u5199\u6210\u9664\u4ee5\u9636\u4e58\u7684\u5f62\u5f0f\uff0c\u56e0\u4e3a x \u6709\u53ef\u80fd\u5f88\u5927\u3002 \u4e3a\u4e86\u4fdd\u8bc1 d/s < 2 d \uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 Wilson \u5b9a\u7406\u5373 (p - 1)! = -1 \u5206\u6cbb FFT \u5df2\u77e5 f_i = \\sum_{j=1}^i f_{i-j} g_j \u548c f_0 \u6c42 f \u8fd9\u4e2a\u663e\u7136\u53ef\u4ee5\u5206\u6cbb\u6765\u505a\uff0c\u5176\u5b9e\u7528\u751f\u6210\u51fd\u6570\u63a8\u7406\u53ef\u77e5 f = \\frac{f_0}{1 - g} \u4e0b\u964d\u5e42\u4e0e\u70b9\u503c \u8bbe n \u6b21\u591a\u9879\u5f0f f(x) = \\sum_{i = 0}^n b_i x^{\\underline{i}} \uff0c\u5219 \\frac{f(m)}{m!} = \\sum_{i = 0}^m b_i \\frac{1}{(m - i)!} \\qquad 0 \\leq m \\leq n \u56e0\u6b64 EGF(f) = b e^x \uff0c\u53cd\u8fc7\u6765\u4e5f\u4e00\u6837 b = EGF(f) e^{-x} \uff08\u6ce8\u610f\u8fd9\u91cc\u53ef\u4ee5\u7b80\u5355\u7684\u591a\u70b9\u6c42\u503c\uff0c\u53ef\u4ee5\u6c42\u66f4\u591a\u7684\u70b9\uff09 \u4e0b\u964d\u5e42\u4e0e\u8fde\u7eed\u70b9\u503c\u6709 O(n \\log n) \u7684\u8f6c\u5316\u3002\u800c\u666e\u901a\u591a\u9879\u5f0f\u8ddf\u8fde\u7eed\u70b9\u503c\u5374\u6ca1\u6709\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u666e\u901a\u591a\u9879\u5f0f\u8981\u7684\u8fde\u7eed\u5176\u5b9e\u662f\u7c7b\u4f3c FFT \u90a3\u6837\u7684\u8fde\u7eed\u3002\u4f46\u662f\u6ce8\u610f\u5230\u4ee5\u8fde\u7eed\u70b9\u6c42\u8fde\u7eed\u70b9\u6709 O(n \\log n) \u7684\u505a\u6cd5 Binom \u8fd9\u91cc\u7684\u5355\u4f8b\u5f88\u79c0\u7684\u4e00\u70b9\u5c31\u662f\u7528\u4e86 const \u5f15\u7528\uff0c\u4f46\u662f\u5374\u4e0d\u59a8\u788d\u6211\u4fee\u6539\u5b83\u7684\u503c\uff01\u8fd9\u6837\u7684\u597d\u5904\uff1a \u5bf9\u4e8e MInt<M> \u76f4\u63a5\u521d\u59cb\u5316\u4e86\uff0c\u4e0d\u7528\u5728 setMod \u5bf9\u4e8e ModInt, ModLL \u8fd9\u4e9b\u672c\u6765\u5c31\u8981 setMod\uff0c\u90a3\u5c31\u7ed9\u5b83\u8c03\u7528 setMod \u91cd\u65b0\u5237\u65b0 Binom \u7684\u503c \u6e90\u4ee3\u7801\u5728\u6362 mod \u7684\u65f6\u5019\u4f1a\u6709 bug\uff0c\u4e8e 2021-7-24 \u91cd\u6784 Poly\uff0c\u901a\u8fc7\u7ee7\u627f vector \u65b9\u5f0f\u800c\u975e vector \u53d8\u91cf\u7684\u65b9\u5f0f\u7684\u65f6\u5019\u53d1\u73b0\u4e86\u8fd9\u4e2a bug \u5e76\u4fee\u590d\u4e86 \u6ce8\u610f\u4e8b\u9879 \uff1a\u5982\u679c\u5229\u7528\u4e86 vector \u8fd9\u79cd\u7ed3\u6784\uff0c\u7136\u540e\u518d\u7528\u5f15\u7528\u53ef\u80fd\u4f1a\u56e0\u6269\u5bb9\u800c\u5bfc\u81f4 RE\uff0c\u53ef\u4ee5\u901a\u8fc7\u9884\u5148\u7533\u8bf7\u8f83\u5927\u7684\u5185\u5b58\u7684\u505a\u6cd5\uff0c\u6b64\u540e\u4e0d\u8981\u968f\u4fbf\u7528 .back() \u8fd9\u7c7b\u4e0d\u786e\u5b9a\u7684\u8c03\u7528 Lagrange \u53cd\u6f14 \u82e5 f(x), g(x) \\in F[[x]] \u4e14 f(g(x) = x \uff0c\u5219 [x^n] g(x) = \\frac{1}{n} [x^{-1}] \\frac{1}{f(x)^n} \u7279\u522b\u5730\uff0c\u82e5 f(x) = \\frac{x}{\\phi(x)} \uff0c\u5219 [x^n] g(x) = \\frac{1}{n} [x^{n-1}] \\phi(x)^n \u51e0\u4f55 \u4e8c\u7ef4\u51f8\u5305 \u65cb\u8f6c\u5361\u58f3\uff08\u5f7b\u5e95\u5f04\u61c2\u539f\u7406\uff0c\u4e4b\u540e\u5e94\u7528\u6b64\u539f\u7406\u63a8\u5e7f\u5e94\u7528\u89e3\u51b3\uff1ahttps://www.luogu.com.cn/problem/P7164\uff09 \u5206\u6cbb\u6cd5\u6c42\u5e73\u9762\u6700\u77ed\u8ddd\u79bb k \u7ef4\u504f\u5e8f\u4e4b bitset \u66b4\u529b\u4f18\u5316 O(\\frac{k n^2}{w}) \u56db\u8fb9\u5f62\u4f18\u5316 DP \u56fe\u8bba dfs \u5e8f Euler \u5e8f \u6700\u8fd1\u516c\u5171\u7956\u5148 LCA \u6700\u5c0f\u751f\u6210\u6811 Prim \u6700\u5c0f\u6811\u5f62\u56fe LiuZhu \u62d3\u6251\u6392\u5e8f Euler \u8def Hamilton \u8def\uff1f\uff08NPC \u95ee\u9898\uff0c\u4e0b\u6b21\u4e00\u5b9a\uff09 \u5e26\u8def\u5f84 Floyd \u6700\u77ed\u8def Dijkstra \u6700\u77ed\u8def BellmaFord \u6700\u77ed\u8def SPFA \u8fde\u901a\u5206\u91cf\u4e4b Kosaraju \u7f29\u70b9 \u8fde\u901a\u5206\u91cf\u4e4b 2-SAT \u5272\u70b9\u5272\u8fb9 \u6709\u5411\u56fe S-T \u6700\u5927\u6d41 Dinic O(n^2 m) \u6709\u5411\u56fe S-T \u6700\u5927\u6d41\u7684\u6700\u9ad8\u6807\u53f7\u9884\u6d41\u63a8\u8fdb\u7b97\u6cd5\uff08HLPP\uff09 O(n^2 \\sqrt{m}) \u7b97\u6cd5 \u65e0\u5411\u56fe\u5168\u5c40\u6700\u5c0f\u5272 StoerWagner \u7b97\u6cd5 \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff08\u52bf\u80fd Dijkstra\uff09 \u4e09\u5143\u73af\u8ba1\u6570 \u4e09\u5143\u73af\u8ba1\u6570\u4e0a\u754c O(m \\sqrt{m}) \u9996\u5148\u5b9a\u5411\u4e4b\u540e\uff0c\u6bcf\u6761\u8fb9\u7684\u51fa\u5ea6\u4e0d\u4f1a\u8d85\u8fc7 \\sqrt{m} \uff08\u5999\u554a\uff09\uff0c\u8fd9\u662f\u56e0\u4e3a - \u539f\u6765\u4e0d\u8d85\u8fc7\u7684\u5fc5\u7136\u4e0d\u8d85\u8fc7 - \u539f\u6765\u8d85\u8fc7\u7684\u53ea\u4f1a\u8fde\u5ea6\u5927\u4e8e\u7b49\u4e8e\u5b83\u7684\uff0c\u8fd9\u4e2a\u4e2a\u6570\u4e0d\u4f1a\u8d85\u8fc7 \\sqrt{m} \u5b57\u7b26\u4e32 Trie \u666e\u901a\u5b57\u7b26\u4e32\u7248 Trie01 \u6c42\u4e24\u4e24\u5f02\u6216\u6700\u5927\u503c\uff08\u53ef\u5728\u7ebf\uff09 Trie01(FusionTree) \u6c42\u5f02\u6216\u548c\uff08\u652f\u6301\u4fee\u6539\uff0c\u5168\u5c40\u52a0 1\uff09 \u524d\u7f00\u51fd\u6570 \u57fa\u4e8e\u524d\u7f00\u51fd\u6570\u7684 KMP \u7b97\u6cd5 \u57fa\u4e8e\u524d\u7f00\u51fd\u6570\u6c42\u524d\u7f00\u51fa\u73b0\u6b21\u6570 Z-\u51fd\u6570 \u57fa\u4e8e Z-\u51fd\u6570\u7684 KMP \u7b97\u6cd5 AC \u81ea\u52a8\u673a \u540e\u7f00\u6570\u7ec4\u8ba1\u7b97\u7684 O(N) \u8bf1\u5bfc\u6392\u5e8f SA-IS \u7b97\u6cd5 \u6700\u5c0f\u8868\u793a\u6cd5 Lyndon \u5206\u89e3\u7684 Duval \u7b97\u6cd5 \u5904\u7406\u56de\u6587\u7684 Manacher \u7b97\u6cd5 \u6570\u636e\u7ed3\u6784 \u66b4\u529b\u679a\u4e3e \u7ea0\u9519\u7801 \u79bb\u6563\u5316 \u5e76\u67e5\u96c6 (Disjoint Union Set) \u6811\u72b6\u6570\u7ec4 (FenwickTree) \u7ebf\u6bb5\u6811 (Segment Tree) \u53ef\u6301\u7eed\u5316\u7ebf\u6bb5\u6811(Persistable Segment Tree) \u6811\u72b6\u6570\u7ec4\u5957\u7ebf\u6bb5\u6811\u6c42\u52a8\u6001\u533a\u95f4\u7b2c k \u5c0f \u83ab\u961f\uff08\u7ebf\u6bb5\u6811\u4e00\u6837\u90fd\u662f\u901a\u7528\u7684\u7c7b\u578b\uff0c\u5177\u4f53\u95ee\u9898\u5177\u4f53\u5199\uff09 \u6700\u957f\uff08\u4e25\u683c\uff09\u9012\u589e\u5b50\u5e8f\u5217 \u5355\u8c03\u961f\u5217 \u5355\u8c03\u6808 \u7b1b\u5361\u5c14\u6811 \u4e09\u7ef4\u504f\u5e8f\u4e4b\u9648\u4e39\u742a\u5206\u6cbb \u7b2c\u4e8c\u5206\u5757\u5dee\u503c\u7248\uff08\u5728\u7ebf\u7b97\u6cd5\uff0c\u79bb\u7ebf\u53ef\u8282\u7701\u7a7a\u95f4\uff09 \u7b2c\u4e8c\u5206\u5757\u7edd\u5bf9\u503c\u7248\uff08\u5728\u7ebf\u7b97\u6cd5\uff0c\u53ef\u641e\u6210\u5e26\u4fee\u6539\u7248\u672c\uff01\uff09","title":"CN"},{"location":"cn/#_1","text":"\u4f7f\u7528\uff1a\u7f16\u8bd1\u5668\u9700\u652f\u6301 C++17\uff0c\u5f3a\u70c8\u5efa\u8bae\u5f00\u542f O2 \u4f18\u5316 \u5206\u7c7b\uff1a\u6570\u5b66\uff0c\u6570\u636e\u7ed3\u6784\uff0c\u5b57\u7b26\u4e32\uff0c\u56fe\u8bba\uff0c\u51e0\u4f55\uff0c\u6742\u7c7b \u7ea6\u5b9a\uff1a\u4ee5 S \u4e3a\u540e\u7f00\u7684\u7b97\u6cd5\u90fd\u662f \u6162\u4e14\u7b80\u5355 \u7684\u7b97\u6cd5\uff0c\uff1f\u8868\u793a\u6682\u672a\u5b9e\u73b0\u3002 \u4e0b\u6807\uff1a\u9ed8\u8ba4\u4ee5 0 \u5f00\u5934\uff0c\u76ee\u524d\u53ea\u6709 \u6811\u72b6\u6570\u7ec4\u548c\u4e00\u4e9b\u6811\u7b97\u6cd5 \u4e3a\u4e86\u65b9\u4fbf\u8d77\u89c1\u4ece 1 \u5f00\u5934\u3002","title":"\u6587\u6863"},{"location":"cn/#_2","text":"\u52a8\u6001\u89c4\u5212 \u4e8c\u5206 \u500d\u589e \u5206\u5757 \u5206\u6cbb \u6c34\u6da8\u8239\u9ad8 \u51b3\u7b56\u5355\u8c03\u6027\u4f18\u5316 Meet in Middle Small to Large","title":"\u601d\u60f3"},{"location":"cn/#_3","text":"","title":"\u6570\u5b66"},{"location":"cn/#primaryhpp","text":"\u6a21\u5feb\u901f\u5e42 \u5411\u4e0a\u53d6\u6574\u548c\u5411\u4e0b\u53d6\u6574 int128 \u8bfb\u5199\uff08\u5feb\u8bfb\uff0cint, long long \u4e5f\u53ef\u4ee5\u4f7f\u7528\uff09 \u4e8c\u8fdb\u5236\u5feb\u901f gcd\uff0c\u62d3\u5c55 gcd \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 CRT \u5e38\u89c4\u4e8c\u9879\u5f0f\u7cfb\u6570\u548c\u6a21\u4e8c\u9879\u5f0f\u7cfb\u6570\uff08\u5355\u4f8b\uff09 Lagrange \u63d2\u503c \u6a21\u81ea\u7136\u6570\u65b9\u5e42\u548c O(k) \u7b97\u6cd5 \u6a21 N \\times N \u77e9\u9635\u4e58\u6cd5\u7c7b\uff08\u7f13\u5b58\u4f18\u5316\uff09 MEX\uff08\u96c6\u5408\u4e2d\u4e0d\u51fa\u73b0\u7684\u6700\u5c0f\u7684\u81ea\u7136\u6570\uff09 \u5feb\u901f\u6392\u5e8f\uff08\u6ca1\u5e26\u968f\u673a\u9009\u62e9\uff0c\u522b\u7528\uff09 \u9884\u5904\u7406\u6700\u5c0f\u7d20\u56e0\u5b50 BerlekampMassey\uff08\u7528\u6765\u627e\u6700\u77ed\u9012\u63a8\u516c\u5f0f\uff09","title":"\u57fa\u7840\u6a21\u5757\uff1aprimary.hpp"},{"location":"cn/#bitcount","text":"\u6bd4 __builtin_popcount \u66f4\u5feb\u7684\u505a\u6cd5 bitCountTable \u67e5\u8868\u6cd5\u5f88\u5feb\uff0c\u4f46\u662f\u7b2c\u4e00\u6b21\u4f1a\u5f88\u6162\uff0c\u56e0\u6b64 __builtin_popcount \u5e76\u672a\u91c7\u7528\u6b64\u65b9\u6cd5 int bitCountTable(unsigned n) { static int table[256] = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, }; return table[n & 0xff] + table[(n >> 8) & 0xff] + table[(n >> 16) & 0xff] + table[n >> 24]; } __builtin_popcount \u6211\u731c\u6d4b\u5b9e\u73b0\u4e3a\u5982\u4e0b\uff08\u5b9e\u6d4b\u8fd0\u884c\u65f6\u95f4\u4e00\u81f4\uff09 int bitCount0(unsigned x) { static const unsigned mask = 0x01010101; return ((mask & x) + (mask & (x >> 1)) + (mask & (x >> 2)) + (mask & (x >> 3)) + (mask & (x >> 4)) + (mask & (x >> 5)) + (mask & (x >> 6)) + (mask & (x >> 7))) % 255; } \u4e5f\u5c31\u662f\u8bf4\u6bcf\u9694 8 \u4e2a bit \u4e00\u4e2a 1\uff0c\u7136\u540e\u4e00\u4e2a\u4e2a\u7684\u52a0\u4e0a\u53bb\uff08\u5206\u6210 4 \u7ec4\uff09\uff0c\u6700\u540e\u8fd9 4 \u7ec4\u7684\u7b54\u6848\u52a0\u8d77\u6765\u7b49\u4ef7\u4e8e\u6a21 255 \u6ce8\u610f\u5230\u5176\u5b9e\u5bf9\u4e8e unsigned\uff0c\u7ed3\u679c\u7684\u6700\u5927\u503c\u4e3a 32\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u7528 6 \u4e2abit \u5c31\u80fd\u5b58\u4e0b\u6240\u6709\u7684\u7b54\u6848\uff0c\u4e8e\u662f\u6211\u4eec\u5176\u5b9e\u53ef\u4ee5\u6bcf\u9694 6 \u4e2a bit \u4e00\u4e2a 1\uff08\u6240\u4ee5\u7528 8 \u8fdb\u5236\u66f4\u5408\u7406\uff09\uff0c\u7136\u540e\u540c\u6837\u4e00\u4e2a\u4e2a\u7684\u52a0\uff08\u5206\u6210 6 \u7ec4\uff09\uff0c\u6700\u540e\u8fd9 6 \u7ec4\u52a0\u8d77\u6765\u7b49\u4ef7\u4e8e\u6a21 63 int bitCount1(unsigned x) { static const unsigned mask = 010101010101; return ((mask & x) + (mask & (x >> 1)) + (mask & (x >> 2)) + (mask & (x >> 3)) + (mask & (x >> 4)) + (mask & (x >> 5))) % 63; } \u4f46\u5176\u5b9e\u53ef\u4ee5\u66f4\u8fd1\u4e00\u6b65\uff0c\u6211\u4eec\u53ef\u4ee5\u5148 3 \u4e2a bit \u4e00\u4e2a 1\uff0c\u7136\u540e\u628a 2 \u4e2a 3bit \u5408\u6210\u4e00\u4e2a 6 bit int bitCount2(unsigned x) { static const unsigned mask = 011111111111; unsigned tmp = (mask & x) + (mask & (x >> 1)) + (mask & (x >> 2)); return ((tmp + (tmp >> 3)) & 030707070707) % 63; } \u7136\u540e\u53ef\u4ee5\u518d\u8fd1\u4e00\u6b65\uff0c\u6ce8\u610f\u5230 (a00)_2 - (a0)_2 - (a)_2 = a , \u6240\u4ee5 (abc)_2 - (ab)_2 - (a) = a + b + c \uff0c\u8fd9\u6837\u53ef\u4ee5\u7701\u4e00\u6b21 & \u64cd\u4f5c int bitCount(unsigned n) { unsigned tmp = n - ((n >> 1) & 033333333333) - ((n >> 2) & 011111111111); return ((tmp + (tmp >> 3)) & 030707070707) % 63; } \u5f53\u7136\u4e86\u6211\u4eec\u8fd8\u9700\u8981\u5904\u7406 unsigned long long\uff0c\u505a\u6cd5\u540c\u7406\uff0c\u5bf9\u4e8e Table \u6cd5\u53ef\u4ee5\u9009\u53d6\u66f4\u5927\u7684 table\uff0c\u6216\u8005\u76f4\u63a5\u5957\u7528\u4e24\u6b21 bitCountTable\uff0c\u800c\u5bf9\u4e8e bitCount \u6b64\u65f6\u5c31\u5e94\u8be5\u9009\u62e9 4/8 bit \u4e00\u6b21\u7684\u505a\u6cd5\u4e86 int bitCountTableLL(unsigned long long n) { return bitCountTable(n >> 32) + bitCountTable(n & 0xffffffff); } int bitCountll(unsigned long long n) { unsigned long long tmp = n - ((n >> 1) & 0x7777777777777777ULL) - ((n >> 2) & 0x3333333333333333ULL) - ((n >> 3) & 0x1111111111111111ULL); return ((tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL) % 255; }","title":"BitCount"},{"location":"cn/#modhpp","text":"MInt: \u8fd9\u4e2a\u662f\u7c7b\u6a21\u677f ModInt ModLL","title":"mod.hpp"},{"location":"cn/#ffthpp","text":"","title":"FFT.hpp"},{"location":"cn/#ntthpp","text":"","title":"NTT.hpp"},{"location":"cn/#fmthpp","text":"\u5feb\u901f Mobius \u53d8\u6362\uff0c\u53eb\u8fd9\u4e2a\u540d\u5b57\u662f\u56e0\u4e3a\u8ddf\u6570\u8bba\u51fd\u6570\u7684 Mobius \u53d8\u6362\u5f62\u5f0f\u4e0a\u4e00\u81f4","title":"FMT.hpp"},{"location":"cn/#numbertheoryhpp","text":"\u5feb\u901f O(n \\log \\log n) \u7d20\u6570\u7b5b\u548c\u6162\u901f\u7ebf\u6027\u7b5b \u5feb\u901f\u8ba1\u7b97 \\pi(x) \u5feb\u901f\u8ba1\u7b97\u7b2c n \u4e2a\u7d20\u6570\uff08\u4ece 1 \u5f00\u59cb\u6807\u53f7\uff0cp[1] = 2\uff0cp[0] \u65e0\u610f\u4e49\uff09 Euler \u7ebf\u6027\u7b5b Mobius \u7ebf\u6027\u7b5b \u62d3\u5c55\u6b27\u62c9\u5b9a\u7406\uff08\u7ed3\u8bba\u5341\u5206\u7b80\u5355\uff0c\u8bc1\u660e\u9700\u8981\u5206\u89e3\u7d20\u56e0\u5f0f\uff09 min_25 \u7b5b O(n^{\\frac{2}{3}}) \u7b97\u6cd5\u6c42 Euler \u51fd\u6570\u524d\u7f00\u548c\uff0cMobius\uff08\u7edd\u5bf9\u503c\uff09\u524d\u7f00\u548c\uff08\u5185\u542b \u6574\u9664\u5206\u5757\uff09 \u6700\u5c0f\u7d20\u56e0\u5b50\u7ebf\u6027\u7b5b \u9884\u5904\u7406\u7d20\u56e0\u5b50\u4e2a\u6570\uff08\u7b97\u91cd/\u4e0d\u7b97\u91cd\uff09 \u7d20\u56e0\u5b50\u5206\u89e3\uff08\u7b97\u91cd/\u4e0d\u7b97\u91cd\uff09 \u6c42\u539f\u6839 \u5927\u7d20\u6570 Miller-Rabin \u6982\u7387\u5224\u522b\u6cd5 Pollard-Pho \u5927\u6574\u6570\u6700\u5927\u6700\u5c0f\u7d20\u56e0\u5b50\u5206\u89e3 \u6a21\u7d20\u6570\u53d6 log\uff08BabyStepGaintStep\uff09 \u6a21\u7d20\u6570\u5f00\u6839\u53f7 O(log^2 p) \u6a21\u7d20\u6570\u5f00\u6839\u53f7 O(log p) \u7684 Cipolla \u7b97\u6cd5 \u6a21\u5076\u7d20\u6570\u5e42\u5f00\u6839\u53f7\uff1f \u6a21\u5947\u7d20\u6570\u5e42\u5f00\u6839\u53f7\uff1f \u6a21\u4efb\u610f\u6570\u5f00\u6839\u53f7\uff08\u5148\u56e0\u5f0f\u5206\u89e3\uff0c\u770b\u4f5c\u6a21\u7d20\u6570\u65b9\u5f00\u6839\u53f7\uff0c\u518d CRT \u6574\u5408\uff09\uff1f","title":"\u521d\u7b49\u6570\u8bba\uff1anumberTheory.hpp"},{"location":"cn/#bigint","text":"","title":"BigInt"},{"location":"cn/#_4","text":"\u5feb\u901f\u66b4\u529b n \u4e2a\u96c6\u5408\u4e2d\u9009 k \u4e2a\uff0c\u4e8c\u8fdb\u5236\u4e3a 1 \u7684\u8868\u793a\u9009\u62e9 KnuthShuffle uniformChoose Fibonacci \u6570\u5217 floorSum\uff1a \\displaystyle \\sum_{i = 0}^{n - 1} \\lfloor \\frac{a \\cdot i + b}{m} \\rfloor sumNum\uff1a \\displaystyle \\sum_{\\sum c_i x_i = m} \\frac{(\\sum x_i)!}{\\prod (x_i !)} decInc: \u6bcf\u6b21\u53ef\u9009\u62e9 n \u51cf\u4e00 \u6216 m \u52a0\u4e00\uff0c\u4f7f\u5f97 m \u662f n \u7684\u500d\u6570\u7684\u6700\u5c0f\u6b21\u6570 Gauss \u6d88\u5143\u6cd5\u6d6e\u70b9\u6570\u7248 \u6a21 Gauss \u6d88\u5143\u6cd5 \u7ebf\u6027\u89c4\u5212\u4e4b\u5355\u7eaf\u5f62\u7b97\u6cd5 \u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5 O(n^{\\log_2 3}) \u7684 Karatsuba \u7b97\u6cd5\uff08\u5305\u62ec\u5e76\u884c\u7248\uff09 \u7ebf\u6027\u89c4\u5212 FirstInRange\uff1a\u6c42\u6700\u5c0f\u7684 x \u4f7f\u5f97 l \\leq a x \\mod m \\leq r \u3002\u7c7b\u4f3c exgcd \u7684\u5904\u7406\uff1a\u6c42\u6700\u5c0f\u975e\u8d1f\u6574\u6570 x \u4f7f\u5f97 l \\leq ax - m y \\leq r \u7b49\u4ef7\u4e8e l \\leq (az - m)y - a(yz - x) \\leq r \uff0c\u6ce8\u610f\u5230\u6211\u4eec\u8981\u59cb\u7ec8\u4fdd\u6301 a < m \uff0c\u56e0\u6b64\u5f53 2a > m \u65f6\u9700\u8981\u7279\u5224\u4e00\u4e0b\u3002\u8f6c\u5316\u6210 m - r \\leq (m - a) x - m(x - y - 1) \\leq m - l","title":"\u6742\u7c7b"},{"location":"cn/#knuthshuffle-uniformchoose","text":"\u6211\u4eec\u4ece\u540e\u5f80\u524d\u641e( a[x] = x )\uff0c\u5047\u8bbe\u5f53\u524d\u8981\u5904\u7406 i \u4f4d\u7f6e\uff0c\u90a3\u4e48 i \u4f4d\u7f6e\u524d\u7684\u4f4d\u7f6e\u4e0d\u53ef\u80fd\u6709\u4ea4\u6362\u7684\u60c5\u51b5\uff0c\u5373\u4e0d\u53ef\u80fd j < k \\leq i , a[j] = k \u6216\u8005 a[k] = j , \u8fd9\u662f\u56e0\u4e3a\u4e00\u4f46\u67d0\u4e2a\u4f4d\u7f6e\u88ab\u6362\u5230\u540e\u9762\u4e4b\u540e\u5c31\u4e0d\u4f1a\u518d\u53d8\u5316\u4e86\u3002 \u6ce8\u610f\u5230\u4e0a\u9762\u8fd9\u4e00\u70b9\uff0c\u5c31\u53ef\u4ee5\u53d1\u73b0 i \u540e\u9762\u7684\u6bcf\u4e2a\u4f4d\u7f6e\u6bcf\u4e2a\u6570\u51fa\u73b0\u7684\u6982\u7387\u5747\u7b49\uff0c\u4e14\u5bf9\u4e8e j \\leq i , a[j] = j \u7684\u6982\u7387\u4e3a \\frac{i}{n} \uff0c\u4e3a i + 1, i + 2, \\cdots, n \u7684\u6982\u7387\u4e3a \\frac{1}{n} \u6240\u4ee5 n \u6b65\u4e4b\u540e\u6240\u6709\u4f4d\u7f6e\u6982\u7387\u90fd\u4e3a \\frac{1}{n} \u6839\u636e\u4e0a\u8ff0\u63a8\u7406\uff0c\u6211\u4eec\u5728 n \u4e2a\u6570\u4e2d\u7b49\u6982\u7387\u7684\u9009\u53d6\u4e0d\u540c\u7684 m \u4e2a\u6570\uff0c\u663e\u7136\u53ea\u9700\u8981\u641e m \u6b65\uff0c\u540e\u9762\u7684 m \u4e2a\u6570\u4e3a\u7b54\u6848\u3002\u7136\u540e\u9ed8\u8ba4 a[i] = i \uff0c\u6240\u4ee5\u7528\u4e00\u4e2a map \u4fdd\u5b58\u6240\u6709 a[i] \u4e0d\u4e00\u5b9a\u4e3a i \u7684\u4f4d\u7f6e\u7684\u503c","title":"KnuthShuffle \u548c uniformChoose \u539f\u7406"},{"location":"cn/#ac","text":"\u4ec5\u5305\u542b\u4e58\u6cd5\u7684\u56db\u5927\u591a\u9879\u5f0f\u5e95\u5c42\u57fa\u7c7b\u5206\u522b\u4e3a\uff1aPolyBaseNTT, PolyBaseMFT3(\u5f03\u7528\uff0c\u88ab\u540e\u9762\u4e24\u4e2a\u6dd8\u6c70\u4e86), PolyBaseMFT4, PolyBaseFFT PolyBaseNTT\uff1a\u57fa\u4e8e\u56fa\u5b9a\u7684 NTT-friendly\uff08\u539f\u6839\u4e00\u822c\u4e3a 3\uff09\u6a21\u6570\u5feb\u901f\u6570\u8bba\u53d8\u5316\uff08\u770b\u5177\u4f53\u9898\u76ee\uff0c\u4e00\u822c\u4e3a 998244353\uff09 PolyBaseMFT3\uff1a\u57fa\u4e8e\u4e09\u4e2a\u56fa\u5b9a\u7684 NTT-friendly \u4e14\u539f\u6839\u4e3a 3 \u7684\u4e09\u6a21\u6570\uff08469762049, 998244353, 1004535809\uff09\uff0c\u5229\u7528 crt \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\uff08\u5df2\u88ab\u6dd8\u6c70\uff0c\u8bf7\u52ff\u4f7f\u7528\uff09 PolyBaseMFT4\uff1a\u57fa\u4e8e\u56db\u4e2a\u56fa\u5b9a\u7684 NTT-friendly \u4e14\u539f\u6839\u4e3a 3 \u7684\u56db\u6a21\u6570\uff08595591169, 645922817, 897581057, 998244353\uff09\uff0c\u5229\u7528 crt \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5 PolyBaseFFT\uff1a\u57fa\u4e8e FFT \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\uff08\u9700\u8981\u6ce8\u610f\u7cbe\u5ea6\uff09 \u901a\u8fc7\u6a21\u677f\u7ee7\u627f\u62d3\u5c55\u5f97\u5230\u5168\u9762\u7684\u591a\u9879\u5f0f\u7c7b Poly (\u52a0\u51cf\u4e58\u9664\u4f59\uff0c\u8f6c\u7f6e\u4e58\u6cd5\uff0c\u6c42\u5bfc\uff0c\u79ef\u5206\uff0c\u6307\u6570\uff0c\u5bf9\u6570\uff0c\u6c42\u9006\uff0c\u5f00\u65b9\uff0c\u4e00\u70b9\u6c42\u503c\uff0c\u591a\u70b9\u6c42\u503c\uff0c\u5feb\u901f\u5e42\u6a21\uff0c\u5185\u79ef\uff0c\u4e00\u4e2a\u9996\u4e00\u591a\u9879\u5f0f\u7684\u6b21\u65b9\u6a21 x^n \u5148\u53d6\u5bf9\u6570\u4e58\u4ee5\u6b21\u6570\u518d\u53d6\u6307\u6570\u5f97\u5230\uff0c\u4e09\u89d2\u51fd\u6570\uff0c\u53cd\u4e09\u89d2\u51fd\u6570)\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5b66\u5230\u4e86\u5f88\u591a\u4e1c\u897f \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a O(n \\log^2 n) \u8ba1\u7b97 \\sum_{i = 1}^n \\frac{a_i}{1 - b_i} \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a O(k \\log k \\log n) \u6c42 k \u9636\u5e38\u7cfb\u6570\u9012\u63a8\u516c\u5f0f\u7684\u7b2c n \u9879 \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a\u6a21\u81ea\u7136\u6570\u65b9\u5e42\u548c O(k \\log k) \u5f97\u5230\u524d k \u4e2a\u7b54\u6848 \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1aLagrange \u63d2\u503c\uff1a\u5148\u5206\u6cbb\u6c42 g(x) = \\prod(x - x_i) \uff0c\u518d\u6c42 g'(x) \u5728 x \u5904\u7684\u591a\u70b9\u6c42\u503c\uff0c\u518d\u5206\u6cbb\u5373\u53ef\u3002 \u6c42\u9636\u4e58 n! \\mod p \uff1a\u57fa\u4e8e\u591a\u70b9\u6c42\u503c O(\\sqrt{n} \\log^2 n) \u6c42 \\sqrt{n} \u4e2a\u70b9\u4e4b\u540e\u66b4\u529b \u6c42\u9636\u4e58 n! \\mod p \uff1amin_25 \u7528\u70b9\u6c42\u70b9 O(\\sqrt{n} \\log n) \u6c42 \\sqrt{n} \u4e2a\u70b9\u4e4b\u540e\u66b4\u529b \u65e0\u8fd0\u7b97\u7684\u591a\u9879\u5f0f\u5e95\u5c42\u57fa\u7c7b\uff1aPolyBase\uff08standard \u5728\u53d6\u4f59\u65f6\uff0c\u7279\u522b\u91cd\u8981\u4e0d\u53ef\u7701\u7565\uff09","title":"\u591a\u9879\u5f0f\uff08\u591a\u9879\u5f0f\u5168\u5bb6\u6876 \u5df2\u5168\u90e8 AC\uff09"},{"location":"cn/#_5","text":"\u591a\u9879\u5f0f\u9879\u6570 N < 4 \\cdot 10^6 M \u8981\u662f\u8d85\u4e86 int\uff0c\u90a3\u5c31\u53ea\u80fd\u7528 ModLL \u7248\u672c 4 \u6a21\u6570 Poly \u5426\u5219\uff0c\u8981\u662f M \u4e0d\u56fa\u5b9a\u5c31\u7528\u4f7f\u7528 ModInt \u7684 FFT \u7248 Poly \u5426\u5219\uff0c\u5f53 M \u4e3a\u56fa\u5b9a\u7684 NTT-friendly \u7d20\u6570\u65f6\uff0c\u4f7f\u7528 NTT \u7248 Poly \u5426\u5219\uff0c\u4f7f\u7528 MInt \u7684 FFT \u7248 Poly","title":"\u4f7f\u7528\u51c6\u5219"},{"location":"cn/#polys","text":"\u7531\u4e8e\u591a\u9879\u5f0f\u6a21\u677f\u4e00\u76f4\u6269\u5c55\uff0c\u52a8\u5219 1000+ \u884c\uff0c\u5b9e\u5728\u6709\u70b9\u641e\uff0c\u6240\u4ee5\u5c31\u641e\u4e86\u4e00\u4e2a\u6781\u7b80\u7248\u7684\u3002","title":"\u6781\u7b80\u7248\u591a\u9879\u5f0f\u6a21\u677f\uff08polyS\uff09"},{"location":"cn/#4-fft","text":"\u6211\u4eec\u672c\u6765\u8981\u6c42 A \\dot B \uff0c\u7136\u540e\u6211\u4eec\u628a\u5b83\u62c6\u6210 A = A_1 + 2^{d} A_2, B = B_1 + 2^d B_2 \uff0c\u90a3\u4e48 AB = A_1 B_1 + (A_1 B_2 + A_2 B_1) 2^d + A_2 B_2 2^{2d} \u4e8e\u662f\u6211\u4eec\u53ea\u9700\u8ba1\u7b97 (A_1 + i A_2)(B_1 + i B_2) \u548c (A_1 + i A_2)(B_1 - i B_2) \u5373\u53ef\uff0c\u4f46\u662f\u6ce8\u610f\u5230 dft((B_1 + i B_2))[j] = \\overline{dft((B_1 + i B_2))[n - j]} \u6240\u4ee5\u672c\u6765\u9700\u8981 5 \u6b21 FFT\uff0c\u73b0\u5728\u53ea\u9700\u8981 4 \u6b21\u5373\u53ef\u3002 \u5176\u5b9e\u672c\u8d28\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u53ea\u505a 3.5 \u6b21 FFT\uff0c\u56e0\u4e3a 2 \u6b21 dft \u6211\u4eec\u53ef\u4ee5\u5f97\u5230 A_1, A_2, B_1, B_2 \u7684 dft \u503c\uff0c\u7136\u540e\u6211\u4eec\u6700\u540e\u53ea\u9700 3 \u6b21\u5b9e\u6570\u7248 idft \u5373\u53ef\uff08\u7b97\u4f5c 1.5 \u6b21\uff09\uff01\u6240\u4ee5\u603b\u7684\u6765\u8bf4\u662f 3.5 \u6b21\u3002\u4f46\u662f\u5b9e\u73b0\u7684\u65f6\u5019\u4e5f\u6ca1\u529e\u6cd5\u641e 0.5 \u6b21\uff0c\u53ef\u60dc\u3002","title":"4 \u6b21 FFT \u539f\u7406"},{"location":"cn/#min_25","text":"\u5b66\u4e60\u8d44\u6599\uff1a zzqsblog , bztMinamoto \u6211\u4eec\u4ee4 s = \\sqrt{n} \u7136\u540e \\displaystyle g_{s}(x) = \\sum_{i = 1}^{s}(x + i) \uff0c\u6211\u4eec\u60f3\u8981\u5f97\u5230 g_s(0), g_s(s), \\cdots g_s((s - 1)s) \u7684\u503c\u3002\u7136\u540e n! = \\prod_{i = 0}^{s - 1} g_s(i s) \\cdot \\prod_{i = s^2 + 1}^n i \u73b0\u5728\u5047\u8bbe\u6211\u4eec\u5df2\u7ecf\u5f97\u5230\u4e86 g_d(0), g_d(s), \\cdots g_d(d s) \u4e00\u4e2a d \u6b21\u591a\u9879\u5f0f\u7531\u5b83\u5728 d + 1 \u4e2a\u4e0d\u540c\u70b9\u7684\u53d6\u503c\u552f\u4e00\u51b3\u5b9a\uff08\u591a\u4e8e d + 1 \u4e2a\u70b9\u4e5f\u53ef\u4ee5\uff09 \u6211\u4eec\u5982\u4f55\u6c42 g_{d + 1}(0), g_{d + 1}(s), \\cdots g_{d + 1}((d + 1) s) \u6ce8\u610f\u5230 g_{d + 1}(x) = g_{d}(x) \\cdot (x + d + 1) \u5373\u53ef O(d) \u8ba1\u7b97\u51fa \u524d d + 1 \u4e2a\uff0c\u6700\u540e\u4e00\u4e2a\u76f4\u63a5\u66b4\u529b\u8ba1\u7b97\u5373\u53ef\u3002 \u6211\u4eec\u5982\u4f55\u6c42 g_{2d}(0), g_{2d}(s), \\cdots g_{2d}(2d s) \u540c\u6837\u6211\u4eec\u6ce8\u610f\u5230 g_{2d}(x) = g_{d}(x) \\cdot g_d(x + d) \u5982\u679c\u6211\u4eec\u8bbe h(i) = g_d(i s) \uff0c\uff08\u90a3\u4e48\u5f88\u5173\u952e\u7684\u4e00\u70b9 g_d(is + d) = g((d / s + i) s = h(d / s + i) \uff0c\u5367\u69fd\uff0c d / s \u5728\u6a21 p \u610f\u4e49\u4e0b\u5f97\u5230\u5c31\u53ef\u4ee5\u4e86\uff0c\u800c\u4e14\u80af\u5b9a\u5927\u4e8e d\uff0c\u5426\u5219\u77db\u76fe\uff01\uff09\u90a3\u4e48\u95ee\u9898\u5c31\u8f6c\u5316\u6210\u5982\u4f55\u6839\u636e\u4e00\u4e2a d \u6b21\u591a\u9879\u5f0f\u7684\u503c\uff1a h(0), h(1), \\cdots, h(d) \u6c42 h(d + 0), \\cdots h(d + d) \u4ee5\u53ca h(d / s + 0), \\cdots h(d / s + d) \u6211\u4eec\u4e0d\u59a8\u5bf9\u4e8e\u4efb\u610f\u7684\u7ed9\u5b9a\u7684 k > d \uff0c\u5148\u6c42\u51fa h(k + 0), h(k + 1), \\cdots h(k + d) \u6ce8\u610f\u5230\u6839\u636e Lagrange \u63d2\u503c\u591a\u9879\u5f0f \\begin{aligned} h(x) &= \\sum_{i = 0}^{d} h(i) \\prod_{j = 0, j \\neq i}^{d} \\frac{x - j}{i - j} \\\\ &= \\sum_{i = 0}^d (-1)^{d - i} h(i) \\binom{x}{i} \\binom{x - i - 1}{d - i} \\\\ &= \\left(\\prod_{i = x - d}^x i \\right) \\sum_{i = 0}^d \\frac{h(i)}{i!(d - i)!(-1)^{d - i}} \\cdot \\frac{1}{(x - i)} \\end{aligned} \u6ce8\u610f\u5230\u8fd9\u91cc\u7684\u5377\u79ef\u8ddf\u6211\u4eec\u666e\u901a\u7684\u5377\u79ef\u4e0d\u4e00\u81f4\uff0c\u5de6\u8fb9\u957f\u5ea6\u4e3a d + 1 \u7684\u591a\u9879\u5f0f\u4e58\u4ee5\u53f3\u8fb9\u957f\u5ea6\u4e3a 2d + 1 \u7684\u591a\u9879\u5f0f\uff0c\u7136\u540e\u6b21\u6570\u4e3a d, \\cdots 2d \u8fd9 d + 1 \u4f4d\u662f\u6709\u6548\u7684\u3002 \u4e0d\u80fd\u5199\u6210\u9664\u4ee5\u9636\u4e58\u7684\u5f62\u5f0f\uff0c\u56e0\u4e3a x \u6709\u53ef\u80fd\u5f88\u5927\u3002 \u4e3a\u4e86\u4fdd\u8bc1 d/s < 2 d \uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 Wilson \u5b9a\u7406\u5373 (p - 1)! = -1","title":"min_25 \u7528\u70b9\u6c42\u70b9\u539f\u7406\uff08\u5176\u5b9e\u53ef\u4ee5\u7528\u4e0b\u964d\u5e42\u66f4\u7b80\u6d01\u7684\u5904\u7406\uff09"},{"location":"cn/#fft","text":"\u5df2\u77e5 f_i = \\sum_{j=1}^i f_{i-j} g_j \u548c f_0 \u6c42 f \u8fd9\u4e2a\u663e\u7136\u53ef\u4ee5\u5206\u6cbb\u6765\u505a\uff0c\u5176\u5b9e\u7528\u751f\u6210\u51fd\u6570\u63a8\u7406\u53ef\u77e5 f = \\frac{f_0}{1 - g}","title":"\u5206\u6cbb FFT"},{"location":"cn/#_6","text":"\u8bbe n \u6b21\u591a\u9879\u5f0f f(x) = \\sum_{i = 0}^n b_i x^{\\underline{i}} \uff0c\u5219 \\frac{f(m)}{m!} = \\sum_{i = 0}^m b_i \\frac{1}{(m - i)!} \\qquad 0 \\leq m \\leq n \u56e0\u6b64 EGF(f) = b e^x \uff0c\u53cd\u8fc7\u6765\u4e5f\u4e00\u6837 b = EGF(f) e^{-x} \uff08\u6ce8\u610f\u8fd9\u91cc\u53ef\u4ee5\u7b80\u5355\u7684\u591a\u70b9\u6c42\u503c\uff0c\u53ef\u4ee5\u6c42\u66f4\u591a\u7684\u70b9\uff09 \u4e0b\u964d\u5e42\u4e0e\u8fde\u7eed\u70b9\u503c\u6709 O(n \\log n) \u7684\u8f6c\u5316\u3002\u800c\u666e\u901a\u591a\u9879\u5f0f\u8ddf\u8fde\u7eed\u70b9\u503c\u5374\u6ca1\u6709\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u666e\u901a\u591a\u9879\u5f0f\u8981\u7684\u8fde\u7eed\u5176\u5b9e\u662f\u7c7b\u4f3c FFT \u90a3\u6837\u7684\u8fde\u7eed\u3002\u4f46\u662f\u6ce8\u610f\u5230\u4ee5\u8fde\u7eed\u70b9\u6c42\u8fde\u7eed\u70b9\u6709 O(n \\log n) \u7684\u505a\u6cd5","title":"\u4e0b\u964d\u5e42\u4e0e\u70b9\u503c"},{"location":"cn/#binom","text":"\u8fd9\u91cc\u7684\u5355\u4f8b\u5f88\u79c0\u7684\u4e00\u70b9\u5c31\u662f\u7528\u4e86 const \u5f15\u7528\uff0c\u4f46\u662f\u5374\u4e0d\u59a8\u788d\u6211\u4fee\u6539\u5b83\u7684\u503c\uff01\u8fd9\u6837\u7684\u597d\u5904\uff1a \u5bf9\u4e8e MInt<M> \u76f4\u63a5\u521d\u59cb\u5316\u4e86\uff0c\u4e0d\u7528\u5728 setMod \u5bf9\u4e8e ModInt, ModLL \u8fd9\u4e9b\u672c\u6765\u5c31\u8981 setMod\uff0c\u90a3\u5c31\u7ed9\u5b83\u8c03\u7528 setMod \u91cd\u65b0\u5237\u65b0 Binom \u7684\u503c \u6e90\u4ee3\u7801\u5728\u6362 mod \u7684\u65f6\u5019\u4f1a\u6709 bug\uff0c\u4e8e 2021-7-24 \u91cd\u6784 Poly\uff0c\u901a\u8fc7\u7ee7\u627f vector \u65b9\u5f0f\u800c\u975e vector \u53d8\u91cf\u7684\u65b9\u5f0f\u7684\u65f6\u5019\u53d1\u73b0\u4e86\u8fd9\u4e2a bug \u5e76\u4fee\u590d\u4e86 \u6ce8\u610f\u4e8b\u9879 \uff1a\u5982\u679c\u5229\u7528\u4e86 vector \u8fd9\u79cd\u7ed3\u6784\uff0c\u7136\u540e\u518d\u7528\u5f15\u7528\u53ef\u80fd\u4f1a\u56e0\u6269\u5bb9\u800c\u5bfc\u81f4 RE\uff0c\u53ef\u4ee5\u901a\u8fc7\u9884\u5148\u7533\u8bf7\u8f83\u5927\u7684\u5185\u5b58\u7684\u505a\u6cd5\uff0c\u6b64\u540e\u4e0d\u8981\u968f\u4fbf\u7528 .back() \u8fd9\u7c7b\u4e0d\u786e\u5b9a\u7684\u8c03\u7528","title":"Binom"},{"location":"cn/#lagrange","text":"\u82e5 f(x), g(x) \\in F[[x]] \u4e14 f(g(x) = x \uff0c\u5219 [x^n] g(x) = \\frac{1}{n} [x^{-1}] \\frac{1}{f(x)^n} \u7279\u522b\u5730\uff0c\u82e5 f(x) = \\frac{x}{\\phi(x)} \uff0c\u5219 [x^n] g(x) = \\frac{1}{n} [x^{n-1}] \\phi(x)^n","title":"Lagrange \u53cd\u6f14"},{"location":"cn/#_7","text":"\u4e8c\u7ef4\u51f8\u5305 \u65cb\u8f6c\u5361\u58f3\uff08\u5f7b\u5e95\u5f04\u61c2\u539f\u7406\uff0c\u4e4b\u540e\u5e94\u7528\u6b64\u539f\u7406\u63a8\u5e7f\u5e94\u7528\u89e3\u51b3\uff1ahttps://www.luogu.com.cn/problem/P7164\uff09 \u5206\u6cbb\u6cd5\u6c42\u5e73\u9762\u6700\u77ed\u8ddd\u79bb k \u7ef4\u504f\u5e8f\u4e4b bitset \u66b4\u529b\u4f18\u5316 O(\\frac{k n^2}{w}) \u56db\u8fb9\u5f62\u4f18\u5316 DP","title":"\u51e0\u4f55"},{"location":"cn/#_8","text":"dfs \u5e8f Euler \u5e8f \u6700\u8fd1\u516c\u5171\u7956\u5148 LCA \u6700\u5c0f\u751f\u6210\u6811 Prim \u6700\u5c0f\u6811\u5f62\u56fe LiuZhu \u62d3\u6251\u6392\u5e8f Euler \u8def Hamilton \u8def\uff1f\uff08NPC \u95ee\u9898\uff0c\u4e0b\u6b21\u4e00\u5b9a\uff09 \u5e26\u8def\u5f84 Floyd \u6700\u77ed\u8def Dijkstra \u6700\u77ed\u8def BellmaFord \u6700\u77ed\u8def SPFA \u8fde\u901a\u5206\u91cf\u4e4b Kosaraju \u7f29\u70b9 \u8fde\u901a\u5206\u91cf\u4e4b 2-SAT \u5272\u70b9\u5272\u8fb9 \u6709\u5411\u56fe S-T \u6700\u5927\u6d41 Dinic O(n^2 m) \u6709\u5411\u56fe S-T \u6700\u5927\u6d41\u7684\u6700\u9ad8\u6807\u53f7\u9884\u6d41\u63a8\u8fdb\u7b97\u6cd5\uff08HLPP\uff09 O(n^2 \\sqrt{m}) \u7b97\u6cd5 \u65e0\u5411\u56fe\u5168\u5c40\u6700\u5c0f\u5272 StoerWagner \u7b97\u6cd5 \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff08\u52bf\u80fd Dijkstra\uff09 \u4e09\u5143\u73af\u8ba1\u6570","title":"\u56fe\u8bba"},{"location":"cn/#om-sqrtm","text":"\u9996\u5148\u5b9a\u5411\u4e4b\u540e\uff0c\u6bcf\u6761\u8fb9\u7684\u51fa\u5ea6\u4e0d\u4f1a\u8d85\u8fc7 \\sqrt{m} \uff08\u5999\u554a\uff09\uff0c\u8fd9\u662f\u56e0\u4e3a - \u539f\u6765\u4e0d\u8d85\u8fc7\u7684\u5fc5\u7136\u4e0d\u8d85\u8fc7 - \u539f\u6765\u8d85\u8fc7\u7684\u53ea\u4f1a\u8fde\u5ea6\u5927\u4e8e\u7b49\u4e8e\u5b83\u7684\uff0c\u8fd9\u4e2a\u4e2a\u6570\u4e0d\u4f1a\u8d85\u8fc7 \\sqrt{m}","title":"\u4e09\u5143\u73af\u8ba1\u6570\u4e0a\u754c O(m \\sqrt{m})"},{"location":"cn/#_9","text":"Trie \u666e\u901a\u5b57\u7b26\u4e32\u7248 Trie01 \u6c42\u4e24\u4e24\u5f02\u6216\u6700\u5927\u503c\uff08\u53ef\u5728\u7ebf\uff09 Trie01(FusionTree) \u6c42\u5f02\u6216\u548c\uff08\u652f\u6301\u4fee\u6539\uff0c\u5168\u5c40\u52a0 1\uff09 \u524d\u7f00\u51fd\u6570 \u57fa\u4e8e\u524d\u7f00\u51fd\u6570\u7684 KMP \u7b97\u6cd5 \u57fa\u4e8e\u524d\u7f00\u51fd\u6570\u6c42\u524d\u7f00\u51fa\u73b0\u6b21\u6570 Z-\u51fd\u6570 \u57fa\u4e8e Z-\u51fd\u6570\u7684 KMP \u7b97\u6cd5 AC \u81ea\u52a8\u673a \u540e\u7f00\u6570\u7ec4\u8ba1\u7b97\u7684 O(N) \u8bf1\u5bfc\u6392\u5e8f SA-IS \u7b97\u6cd5 \u6700\u5c0f\u8868\u793a\u6cd5 Lyndon \u5206\u89e3\u7684 Duval \u7b97\u6cd5 \u5904\u7406\u56de\u6587\u7684 Manacher \u7b97\u6cd5","title":"\u5b57\u7b26\u4e32"},{"location":"cn/#_10","text":"\u66b4\u529b\u679a\u4e3e \u7ea0\u9519\u7801 \u79bb\u6563\u5316 \u5e76\u67e5\u96c6 (Disjoint Union Set) \u6811\u72b6\u6570\u7ec4 (FenwickTree) \u7ebf\u6bb5\u6811 (Segment Tree) \u53ef\u6301\u7eed\u5316\u7ebf\u6bb5\u6811(Persistable Segment Tree) \u6811\u72b6\u6570\u7ec4\u5957\u7ebf\u6bb5\u6811\u6c42\u52a8\u6001\u533a\u95f4\u7b2c k \u5c0f \u83ab\u961f\uff08\u7ebf\u6bb5\u6811\u4e00\u6837\u90fd\u662f\u901a\u7528\u7684\u7c7b\u578b\uff0c\u5177\u4f53\u95ee\u9898\u5177\u4f53\u5199\uff09 \u6700\u957f\uff08\u4e25\u683c\uff09\u9012\u589e\u5b50\u5e8f\u5217 \u5355\u8c03\u961f\u5217 \u5355\u8c03\u6808 \u7b1b\u5361\u5c14\u6811 \u4e09\u7ef4\u504f\u5e8f\u4e4b\u9648\u4e39\u742a\u5206\u6cbb \u7b2c\u4e8c\u5206\u5757\u5dee\u503c\u7248\uff08\u5728\u7ebf\u7b97\u6cd5\uff0c\u79bb\u7ebf\u53ef\u8282\u7701\u7a7a\u95f4\uff09 \u7b2c\u4e8c\u5206\u5757\u7edd\u5bf9\u503c\u7248\uff08\u5728\u7ebf\u7b97\u6cd5\uff0c\u53ef\u641e\u6210\u5e26\u4fee\u6539\u7248\u672c\uff01\uff09","title":"\u6570\u636e\u7ed3\u6784"},{"location":"dataStructure/","text":"dataStructure.hpp Data Structures are ideals or models, It is hard to write once, used everywhere, for example, Segment Tree, Disjoint set union, Mo's algorithm , monicDeque, monicStack. We will provide some Frames (you should implement it to meet for needs) method nextBinom Just the same as next_permutation to bruteForce all permutation, we have nextBinom to bruteForce all Binom. for example bruteForceBinom(2, 4) will get 0 1 0 2 0 3 1 2 1 3 2 3 and It can be used in ECC RingBuffer template class RingBuffer template<typename T> class RingBuffer; discrete #include <bits/stdc++.h> using LL = long long; #include \"cpplib/all.hpp\" int main() { std::cin.tie(nullptr)->sync_with_stdio(false); std::vector<int> a{-12, 232, 12, 23}; auto b = discrete(a); for (auto& x : a) std::cout << x << ' '; std::cout << '\\n'; for (auto& x : b) std::cout << x << ' '; std::cout << '\\n'; return 0; } // output: // 0 3 1 2 // -12 12 23 232 disjointInterval #include <bits/stdc++.h> using LL = long long; #include \"cpplib/all.hpp\" int main() { std::cin.tie(nullptr)->sync_with_stdio(false); std::vector<std::pair<int, int>> a{{-12, 2}, {2, 4}, {1, 3}, {5, 8}}; disjointInterval(a); for (auto [l, r] : a) std::cout << l << ' ' << r << '\\n'; return 0; } // output: // -12 4 // 5 8 DSU: Disjoint Set Union Bit tree BitreeMin: min version Bitree: origin version(provide binary search) BitreePlus: plus version(support segment add) inverse Order Count LL inverseOrderCount(std::vector<int> a); use discrite and Bit tree, we can solve it in O(n \\log n) , where n is the size of a . SegmentTree There are two versions: sum and min/max min/max version slightly hard: you should record min/max , and second min/max value: https://codeforces.com/gym/102992/problem/J Persistent Segment Tree It save all version of update, and version number are saved in roots . Is this data structure used in Git ? BitPstSegTree Bitree inside a Persistent Segment Tree to get dynamic k-th smallest number(online algorithm) subsequence LIS: length of longest increasing subsquence LNDS: length of longest non-decreasing subsquence LISP: (one of) longest increasing subsquence Cartesian Tree CDQ divided and conquer second Block","title":"Data Structure"},{"location":"dataStructure/#datastructurehpp","text":"Data Structures are ideals or models, It is hard to write once, used everywhere, for example, Segment Tree, Disjoint set union, Mo's algorithm , monicDeque, monicStack. We will provide some Frames (you should implement it to meet for needs)","title":"dataStructure.hpp"},{"location":"dataStructure/#method","text":"","title":"method"},{"location":"dataStructure/#nextbinom","text":"Just the same as next_permutation to bruteForce all permutation, we have nextBinom to bruteForce all Binom. for example bruteForceBinom(2, 4) will get 0 1 0 2 0 3 1 2 1 3 2 3 and It can be used in ECC","title":"nextBinom"},{"location":"dataStructure/#ringbuffer","text":"template class RingBuffer template<typename T> class RingBuffer;","title":"RingBuffer"},{"location":"dataStructure/#discrete","text":"#include <bits/stdc++.h> using LL = long long; #include \"cpplib/all.hpp\" int main() { std::cin.tie(nullptr)->sync_with_stdio(false); std::vector<int> a{-12, 232, 12, 23}; auto b = discrete(a); for (auto& x : a) std::cout << x << ' '; std::cout << '\\n'; for (auto& x : b) std::cout << x << ' '; std::cout << '\\n'; return 0; } // output: // 0 3 1 2 // -12 12 23 232","title":"discrete"},{"location":"dataStructure/#disjointinterval","text":"#include <bits/stdc++.h> using LL = long long; #include \"cpplib/all.hpp\" int main() { std::cin.tie(nullptr)->sync_with_stdio(false); std::vector<std::pair<int, int>> a{{-12, 2}, {2, 4}, {1, 3}, {5, 8}}; disjointInterval(a); for (auto [l, r] : a) std::cout << l << ' ' << r << '\\n'; return 0; } // output: // -12 4 // 5 8","title":"disjointInterval"},{"location":"dataStructure/#dsu-disjoint-set-union","text":"","title":"DSU: Disjoint Set Union"},{"location":"dataStructure/#bit-tree","text":"BitreeMin: min version Bitree: origin version(provide binary search) BitreePlus: plus version(support segment add)","title":"Bit tree"},{"location":"dataStructure/#inverse-order-count","text":"LL inverseOrderCount(std::vector<int> a); use discrite and Bit tree, we can solve it in O(n \\log n) , where n is the size of a .","title":"inverse Order Count"},{"location":"dataStructure/#segmenttree","text":"There are two versions: sum and min/max min/max version slightly hard: you should record min/max , and second min/max value: https://codeforces.com/gym/102992/problem/J","title":"SegmentTree"},{"location":"dataStructure/#persistent-segment-tree","text":"It save all version of update, and version number are saved in roots . Is this data structure used in Git ?","title":"Persistent Segment Tree"},{"location":"dataStructure/#bitpstsegtree","text":"Bitree inside a Persistent Segment Tree to get dynamic k-th smallest number(online algorithm)","title":"BitPstSegTree"},{"location":"dataStructure/#subsequence","text":"LIS: length of longest increasing subsquence LNDS: length of longest non-decreasing subsquence LISP: (one of) longest increasing subsquence","title":"subsequence"},{"location":"dataStructure/#cartesian-tree","text":"","title":"Cartesian Tree"},{"location":"dataStructure/#cdq-divided-and-conquer","text":"","title":"CDQ divided and conquer"},{"location":"dataStructure/#second-block","text":"","title":"second Block"},{"location":"graph/","text":"graph.hpp Notation: n (numbers of vertex), m (numbers of edges) Tree DfsTour EulerTour LCA Prim: Minimum Spanning Tree LiuZhu: Minimum tree diagram TopSort EulerPath link/cut Tree , dsu on tree need case-by-case analysis. Shortest Path Floyd BellmanFord Dijkstra spfa Connectivity Scc: Strongly Connected Components twoSAT cutVertex CutEdge Flow Dinic: S-T max-Flow O(n^2 m) HLPP: S-T max-Flow O(n^2 \\sqrt{m}) Stoer-Wagner: Global minimum cut of undirected graph( O(n^3) implement) Flow: minimum cost maximum flow Mixed circle3count: count (a, b), (b, c), (c, a) in undirected graph","title":"Graph Theory"},{"location":"graph/#graphhpp","text":"Notation: n (numbers of vertex), m (numbers of edges)","title":"graph.hpp"},{"location":"graph/#tree","text":"DfsTour EulerTour LCA Prim: Minimum Spanning Tree LiuZhu: Minimum tree diagram TopSort EulerPath link/cut Tree , dsu on tree need case-by-case analysis.","title":"Tree"},{"location":"graph/#shortest-path","text":"Floyd BellmanFord Dijkstra spfa","title":"Shortest Path"},{"location":"graph/#connectivity","text":"Scc: Strongly Connected Components twoSAT cutVertex CutEdge","title":"Connectivity"},{"location":"graph/#flow","text":"Dinic: S-T max-Flow O(n^2 m) HLPP: S-T max-Flow O(n^2 \\sqrt{m}) Stoer-Wagner: Global minimum cut of undirected graph( O(n^3) implement) Flow: minimum cost maximum flow","title":"Flow"},{"location":"graph/#mixed","text":"circle3count: count (a, b), (b, c), (c, a) in undirected graph","title":"Mixed"},{"location":"string/","text":"string.hpp Tire Trie: build a Trie Trie01: find max xor sum FusionTree: special Trie01, get xor sum(support modifty, add 1 to all) KMP prefixFunction kmp countPrefix zFunction kmpZ Automaton Suffix array minPresent Lyndon decomposition Palindrome","title":"String"},{"location":"string/#stringhpp","text":"","title":"string.hpp"},{"location":"string/#tire","text":"Trie: build a Trie Trie01: find max xor sum FusionTree: special Trie01, get xor sum(support modifty, add 1 to all)","title":"Tire"},{"location":"string/#kmp","text":"prefixFunction kmp countPrefix zFunction kmpZ","title":"KMP"},{"location":"string/#automaton","text":"","title":"Automaton"},{"location":"string/#suffix-array","text":"","title":"Suffix array"},{"location":"string/#minpresent","text":"","title":"minPresent"},{"location":"string/#lyndon-decomposition","text":"","title":"Lyndon decomposition"},{"location":"string/#palindrome","text":"","title":"Palindrome"},{"location":"math/basic/","text":"baisc.hpp powMod int powMod(int x, int n, int M) \\text{powMod}(x, n, M) = x^n \\mod p Constraints 0 \\leq x < M n \\geq 0 M \\geq 1 Complexity O(\\log n) ctz int ctz32(unsigned x); int ctz64(unsigned long long x); Slow than __builtin_ctz and __builtin_ctzll but funny. bitCount we may use __builtin_popcount , or __builtin_popcountll in g++(but not in clang++), but it is slower than the following methods int bitCount(unsigned n); int bitCountll(unsigned long long n); // The fastest so far for 64bit int BitCountTable(unsigned n); // The fastest so far for 32bit int BitCountTablell(unsigned long long n); bitCountTable use static Table of length 256, and bitCount and bitCountll use MIT HAKMEM, since 2^6 = 64 > 32 , and 2^8 = 256 > 64 parity bool parity(unsigned n); bool parityll(unsigned long long n); bool parityTable(unsigned n); bool parityTablell(unsigned long long n); bool parityMIT(unsigned n); bool parityMITll(unsigned long long n); All above are sightly slow than __builtin_parity and __builtin_parityll acos, asin floor and ceil template<typename T> T floor(T a, T n) template<typename T> T ceil(T a, T n) \\text{floor}(a, n) = \\lfloor \\frac{a}{n} \\rfloor \\text{ceil}(a, n) = \\lceil \\frac{a}{n} \\rceil Constraints n \\neq 0 T can be (unsigned) int , LL an so on Complexity O(1) __int128 : input and output __int128 int128::read() void int128::print() Constraints Never use it with cin and cout Complexity O(\\log n) gcd // Binary GCD: slightly faster than std::gcd LL gcd(LL a, LL b) Complexity O(\\log \\text{lcm}(a, b)) Reference cp-algorithm exGcd template<typename T> std::tuple<T, T, T> exGcd(T a, T b) // auto [d, x, y] = exGcd(a, b) where d = \\gcd(a, b) = ax + by Constraints T can be (unsigned) int , long long Complexity O(\\log \\text{lcm}(a, b)) crt2 std::pair<LL, LL> crt2(LL a1, LL m1, LL a2, LL m2) // auto [a, m] = crt2(a1, m1, a2, m2) The Chinese Remainder Theorem shows that x \\equiv a \\mod m equivalence to x \\equiv a_i \\mod m_i, \\quad i = 1, 2 Constraints \\text{lcm}(m_1, m_2) is in LL 0 \\leq a_1 < m_1, 0 \\leq a_2 < m_2 Complexity O(\\log \\text{lcm}(m_1, m_2)) crt std::pair<LL, LL> crt(const std::vector<std::pair<LL, LL>>& A) // n = (int)A.size(), a[i] = A[i].first, m[i] = A[i].second, use crt2 above n - 1 times, we have x \\equiv a \\mod m equivalence to x \\equiv a_i \\mod m_i, \\quad i = 1, 2, \\cdots, n Constraints \\text{lcm}(m_i) is in LL 0 \\leq a_i < m_i Complexity O(\\log \\text{lcm}(m_i)) Dependence crt2 spf (foundmental important) std::vector<int> spf(int N) // auto sp = spf(N) where sp[x] is smallest prime factor of x Complexity O(\\log N) Binom It is a const singleton class with static const int number N = 65 , and C[N][N] . c[i][j] = \\binom{i}{j} exmaple Binom C; std::cout << C(4, 2) << '\\n'; // the answer is 6 BinomModp It is a ~~singleton~~ template class, with typename valT since valT::mod() may change in progress, It is not wise to use singleton Members and Methods fac , ifac , inv \\text{binom}(n, k) \\doteq \\binom{n}{k} = fac[n] \\cdot ifac[k] \\cdot ifac[n - k] if 0 \\leq k \\leq n , 0 else. Constraints valT should be MInt , ModInt or ModLL defined in mod.hpp valT::mod() \\geq n Complexity O(n) Lagrange template<typename valT> valT Lagrange(const std::vector<valT>& f, int m) Calculate f(m) where f is the Lagrange interpolation on f(0), f(1), \\cdots, f(n - 1) Complexity O(n) Dependence BinomModp powSum valT powSum(int n, int k, const std::vector<int>& sp) \\displaystyle \\text{powSum}(n, k) = \\sum_{i = 0}^n i^k , where sp[x] is smallest prime factor of x Complexity O(k) Dependence Lagrange spf Matrix It is a class template, contains matrix add, multiplication, and pow Complexity + : O(N^2) * : O(N^3) pow(A, n) : O(N^3 \\log n) MEX It is a class contains static const int B = 20 and set S , you can Insert/erase element to S , and \\text{MEX.solve}(x) = MEX_{a_i \\in S} (a_i \\oplus x) Constraints \\forall x \\in S, x < 2^B Complexity O(|S| \\log |S|) MEXS the maximal value should not too large trans transform vector<int> to vector<valT> Complexity O(n) BerlekampMassey(every useful) static std::vector<valT> BerlekampMassey(const std::vector<valT>& a) It return shortest recursive relational formula of a . Complexity O(n^2) Example BerlekampMassey({1, 2, 4, 8, 16}) = {2} BerlekampMassey({1, 1, 2, 3, 5}) = {1, 1}","title":"basic"},{"location":"math/basic/#baischpp","text":"","title":"baisc.hpp"},{"location":"math/basic/#powmod","text":"int powMod(int x, int n, int M) \\text{powMod}(x, n, M) = x^n \\mod p Constraints 0 \\leq x < M n \\geq 0 M \\geq 1 Complexity O(\\log n)","title":"powMod"},{"location":"math/basic/#ctz","text":"int ctz32(unsigned x); int ctz64(unsigned long long x); Slow than __builtin_ctz and __builtin_ctzll but funny.","title":"ctz"},{"location":"math/basic/#bitcount","text":"we may use __builtin_popcount , or __builtin_popcountll in g++(but not in clang++), but it is slower than the following methods int bitCount(unsigned n); int bitCountll(unsigned long long n); // The fastest so far for 64bit int BitCountTable(unsigned n); // The fastest so far for 32bit int BitCountTablell(unsigned long long n); bitCountTable use static Table of length 256, and bitCount and bitCountll use MIT HAKMEM, since 2^6 = 64 > 32 , and 2^8 = 256 > 64","title":"bitCount"},{"location":"math/basic/#parity","text":"bool parity(unsigned n); bool parityll(unsigned long long n); bool parityTable(unsigned n); bool parityTablell(unsigned long long n); bool parityMIT(unsigned n); bool parityMITll(unsigned long long n); All above are sightly slow than __builtin_parity and __builtin_parityll","title":"parity"},{"location":"math/basic/#acos-asin","text":"","title":"acos, asin"},{"location":"math/basic/#floor-and-ceil","text":"template<typename T> T floor(T a, T n) template<typename T> T ceil(T a, T n) \\text{floor}(a, n) = \\lfloor \\frac{a}{n} \\rfloor \\text{ceil}(a, n) = \\lceil \\frac{a}{n} \\rceil Constraints n \\neq 0 T can be (unsigned) int , LL an so on Complexity O(1)","title":"floor  and ceil"},{"location":"math/basic/#__int128-input-and-output","text":"__int128 int128::read() void int128::print() Constraints Never use it with cin and cout Complexity O(\\log n)","title":"__int128 : input and output"},{"location":"math/basic/#gcd","text":"// Binary GCD: slightly faster than std::gcd LL gcd(LL a, LL b) Complexity O(\\log \\text{lcm}(a, b)) Reference cp-algorithm","title":"gcd"},{"location":"math/basic/#exgcd","text":"template<typename T> std::tuple<T, T, T> exGcd(T a, T b) // auto [d, x, y] = exGcd(a, b) where d = \\gcd(a, b) = ax + by Constraints T can be (unsigned) int , long long Complexity O(\\log \\text{lcm}(a, b))","title":"exGcd"},{"location":"math/basic/#crt2","text":"std::pair<LL, LL> crt2(LL a1, LL m1, LL a2, LL m2) // auto [a, m] = crt2(a1, m1, a2, m2) The Chinese Remainder Theorem shows that x \\equiv a \\mod m equivalence to x \\equiv a_i \\mod m_i, \\quad i = 1, 2 Constraints \\text{lcm}(m_1, m_2) is in LL 0 \\leq a_1 < m_1, 0 \\leq a_2 < m_2 Complexity O(\\log \\text{lcm}(m_1, m_2))","title":"crt2"},{"location":"math/basic/#crt","text":"std::pair<LL, LL> crt(const std::vector<std::pair<LL, LL>>& A) // n = (int)A.size(), a[i] = A[i].first, m[i] = A[i].second, use crt2 above n - 1 times, we have x \\equiv a \\mod m equivalence to x \\equiv a_i \\mod m_i, \\quad i = 1, 2, \\cdots, n Constraints \\text{lcm}(m_i) is in LL 0 \\leq a_i < m_i Complexity O(\\log \\text{lcm}(m_i)) Dependence crt2","title":"crt"},{"location":"math/basic/#spf-foundmental-important","text":"std::vector<int> spf(int N) // auto sp = spf(N) where sp[x] is smallest prime factor of x Complexity O(\\log N)","title":"spf (foundmental important)"},{"location":"math/basic/#binom","text":"It is a const singleton class with static const int number N = 65 , and C[N][N] . c[i][j] = \\binom{i}{j}","title":"Binom"},{"location":"math/basic/#exmaple","text":"Binom C; std::cout << C(4, 2) << '\\n'; // the answer is 6","title":"exmaple"},{"location":"math/basic/#binommodp","text":"It is a ~~singleton~~ template class, with typename valT since valT::mod() may change in progress, It is not wise to use singleton Members and Methods fac , ifac , inv \\text{binom}(n, k) \\doteq \\binom{n}{k} = fac[n] \\cdot ifac[k] \\cdot ifac[n - k] if 0 \\leq k \\leq n , 0 else. Constraints valT should be MInt , ModInt or ModLL defined in mod.hpp valT::mod() \\geq n Complexity O(n)","title":"BinomModp"},{"location":"math/basic/#lagrange","text":"template<typename valT> valT Lagrange(const std::vector<valT>& f, int m) Calculate f(m) where f is the Lagrange interpolation on f(0), f(1), \\cdots, f(n - 1) Complexity O(n) Dependence BinomModp","title":"Lagrange"},{"location":"math/basic/#powsum","text":"valT powSum(int n, int k, const std::vector<int>& sp) \\displaystyle \\text{powSum}(n, k) = \\sum_{i = 0}^n i^k , where sp[x] is smallest prime factor of x Complexity O(k) Dependence Lagrange spf","title":"powSum"},{"location":"math/basic/#matrix","text":"It is a class template, contains matrix add, multiplication, and pow Complexity + : O(N^2) * : O(N^3) pow(A, n) : O(N^3 \\log n)","title":"Matrix"},{"location":"math/basic/#mex","text":"It is a class contains static const int B = 20 and set S , you can Insert/erase element to S , and \\text{MEX.solve}(x) = MEX_{a_i \\in S} (a_i \\oplus x) Constraints \\forall x \\in S, x < 2^B Complexity O(|S| \\log |S|)","title":"MEX"},{"location":"math/basic/#mexs","text":"the maximal value should not too large","title":"MEXS"},{"location":"math/basic/#trans","text":"transform vector<int> to vector<valT> Complexity O(n)","title":"trans"},{"location":"math/basic/#berlekampmasseyevery-useful","text":"static std::vector<valT> BerlekampMassey(const std::vector<valT>& a) It return shortest recursive relational formula of a . Complexity O(n^2) Example BerlekampMassey({1, 2, 4, 8, 16}) = {2} BerlekampMassey({1, 1, 2, 3, 5}) = {1, 1}","title":"BerlekampMassey(every useful)"},{"location":"math/geometry/","text":"geometry.hpp It contains only elementary methods for geometry Geomerty It is a namespace contains following methods using Point = std::pair<double, double>; double cross(const Point& op, const Point& sp, const Point& ep) // cross product bool crossLeft(const Point& op, const Point& sp, const Point& ep) // check if cross product is positive double dist2(const Point& p, const Point& q) // square of distance double dist (const Point& p, const Point& q) // dist std::vector<Point> convexHull(std::vector<Point> p) // convexHull of p double diameter(std::vector<Point> p) // find greatest distance in between Vertices of p double minDist(std::vector<Point> a) // find smallest distance in between Vertices of a Complexity : cross, crossLeft, dist, dist2: O(1) convexHull, diameter: O(n \\log n) minDist: O(n \\log^2 n) partialOrder partial order of dimension k (optimed by bitset) Complexity : O(\\frac{n^2}{w}) where w = 32,\\;64 rectangleUnion using dynamic segment tree Complexity : O(n \\log n)","title":"geometry"},{"location":"math/geometry/#geometryhpp","text":"It contains only elementary methods for geometry","title":"geometry.hpp"},{"location":"math/geometry/#geomerty","text":"It is a namespace contains following methods using Point = std::pair<double, double>; double cross(const Point& op, const Point& sp, const Point& ep) // cross product bool crossLeft(const Point& op, const Point& sp, const Point& ep) // check if cross product is positive double dist2(const Point& p, const Point& q) // square of distance double dist (const Point& p, const Point& q) // dist std::vector<Point> convexHull(std::vector<Point> p) // convexHull of p double diameter(std::vector<Point> p) // find greatest distance in between Vertices of p double minDist(std::vector<Point> a) // find smallest distance in between Vertices of a Complexity : cross, crossLeft, dist, dist2: O(1) convexHull, diameter: O(n \\log n) minDist: O(n \\log^2 n)","title":"Geomerty"},{"location":"math/geometry/#partialorder","text":"partial order of dimension k (optimed by bitset) Complexity : O(\\frac{n^2}{w}) where w = 32,\\;64","title":"partialOrder"},{"location":"math/geometry/#rectangleunion","text":"using dynamic segment tree Complexity : O(n \\log n)","title":"rectangleUnion"},{"location":"math/mixed/","text":"mixed.hpp BigInt See BigInt for detail. Complexity add, sub: O(n) mul, div: O(n \\log n) where n is the length of number in decimal. GospersHack void GospersHack(int n, int k) brute-force all case: n choose k , 1 stand for choosen you should implement it to meet to feed your needs Complexity O(\\binom{n}{k}) twoSumCount int twoSumCount(int n, int d) return |\\{(i, j) : 0 < i, j < n, i + j = d\\}| KnuthShuffle template<typename T> void KnuthShuffle(std::vector<T>& a) Knuth Shuffle Algorithm Complexity O(n) uniformChoose std::vector<int> uniformChoose(int n, int m) Choose m distinct elements from [0, n) with equal probability using the ideal of Knuth Shuffle Algorithm Complexity O(m \\log m) Constraints m \\leq n Fib int Fib(int n, int M) return n -th Fibonacci number mod M . Complexity O(\\log n) floorSum LL floorSum(int n, int m, int a, int b) \\displaystyle \\text{floorSum}(n, m, a, b) = \\sum_{i = 0}^{n - 1} \\lfloor \\frac{a \\cdot i + b}{m} \\rfloor Complexity O(\\log m) sumNum int sumNum(const std::vector<int>& c, int m, int M) \\displaystyle \\text{sumNum}(c, m, M) = \\sum_{\\sum c_i x_i = m} \\frac{(\\sum x_i)!}{\\prod (x_i !)} \\mod M Complexity O(m) decInc int decInc(int n, int m) count min time: every time --n or ++m s.t. n \\mid m Complexity O(\\sqrt{m}) Example \\text{decInc}(3, 3) = 0 \\text{decInc}(5, 3) = 2 \\text{decInc}(4, 9) = 1 FirstInRange int FirstInRange(int a, int m, int l, int r) finds min x s.t. l \\leq a x \\mod m \\leq r (or -1 if it does not exist) Constraints 0 \\leq l \\leq r < m 0 \\leq a < M Complexity O(\\log m) RecSeq template<typename T> // use ModInt, MInt, ModLL class RecSeq : public std::vector<T>; It is used to avoid use matrix multiplication in dp Gauss std::vector<double> Gauss(std::vector<std::vector<double>> A, std::vector<double> b) Gauss-Jordan Elimination Ax = b , float version, Inspire by spookywooky Complexity O(n^3) GaussModp std::vector<valT> GaussModp(std::vector<std::vector<valT>> A, std::vector<valT> b) Gauss-Jordan Elimination Ax = b , mod version Complexity O(n^3) simplex using VD = std::vector<double> VD simplex(VD c, std::vector<VD> Aq, VD bq, std::vector<VD> Alq, VD blq) Simplex algorithm for linear programming: compute max cx with constraints: Aq \\cdot x = bq and Alq \\cdot x \\leq blq Karatsuba using VL = std::vector<LL> VL Karatsuba(VL a, VL b, LL p) Polynomial multiplication with arbitrary modulus Complexity O(n^{\\log_2 3}) There is a parallel version of Karatsuba(you may need -lpthread to complier): KaratsubaParallel quadrangleItvDp std::vector<std::vector<T>> quadrangleItvDp(std::vector<std::vector<T>> w, int n) f_{l, r} = \\min_{l \\leq k < r} f_{l, k} + f_{k + 1, r} + w(l, r) \\qquad (1 \\leq l < r \\leq n) It is a common tech for Segment DP optim: O(n^3) to O(n^2) Complexity O(n^2) quadrangleRollDp std::vector<std::vector<T>> quadrangleRollDp(std::vector<std::vector<T>> w, int n, int m) f_{i, j} = \\min_{k < j} f_{i - 1, k} + w(k + 1, j) \\quad (1 \\leq i \\leq n, 1 \\leq j \\leq m) It is a common tech for oll DP optim: O(n^3) to O(n^2) Complexity O(n m) PalindromeNumber It is a singleton class. Recall that n is a Palindrome Number if it's digits representation is a palindrome, for example 1, 121, 33, 23532 are Palindrome Number which 132, 112 are not. LL nthPalindrome(int k) return k -th Palindrome Number. Constraints k < 10^9 Complexity O(\\log k) Example \\text{nthPalindrome}(1) = 1 \\text{nthPalindrome}(10) = 11 \\text{nthPalindrome}(20) = 111 int Palindrome(LL n) return numbers of Palindrome less that n Constraints n < 10^{18} Complexity O(\\log n) Example \\text{Palindrome}(1) = 0 \\text{Palindrome}(111) = 19 LL solve(LL n, int k) { return nthPalindrome(k + Palindrome(n)); } return k -th Palindrome Number greater than or equal to n fast powMod unsigned fastPowMod998244353(unsigned x, unsigned n); unsigned fastPowMod1000000007(unsigned x, unsigned n); unsigned fastPowMod1000000009(unsigned x, unsigned n); however only fastPowMod998244353 faster than 20%","title":"mixed"},{"location":"math/mixed/#mixedhpp","text":"","title":"mixed.hpp"},{"location":"math/mixed/#bigint","text":"See BigInt for detail. Complexity add, sub: O(n) mul, div: O(n \\log n) where n is the length of number in decimal.","title":"BigInt"},{"location":"math/mixed/#gospershack","text":"void GospersHack(int n, int k) brute-force all case: n choose k , 1 stand for choosen you should implement it to meet to feed your needs Complexity O(\\binom{n}{k})","title":"GospersHack"},{"location":"math/mixed/#twosumcount","text":"int twoSumCount(int n, int d) return |\\{(i, j) : 0 < i, j < n, i + j = d\\}|","title":"twoSumCount"},{"location":"math/mixed/#knuthshuffle","text":"template<typename T> void KnuthShuffle(std::vector<T>& a) Knuth Shuffle Algorithm Complexity O(n)","title":"KnuthShuffle"},{"location":"math/mixed/#uniformchoose","text":"std::vector<int> uniformChoose(int n, int m) Choose m distinct elements from [0, n) with equal probability using the ideal of Knuth Shuffle Algorithm Complexity O(m \\log m) Constraints m \\leq n","title":"uniformChoose"},{"location":"math/mixed/#fib","text":"int Fib(int n, int M) return n -th Fibonacci number mod M . Complexity O(\\log n)","title":"Fib"},{"location":"math/mixed/#floorsum","text":"LL floorSum(int n, int m, int a, int b) \\displaystyle \\text{floorSum}(n, m, a, b) = \\sum_{i = 0}^{n - 1} \\lfloor \\frac{a \\cdot i + b}{m} \\rfloor Complexity O(\\log m)","title":"floorSum"},{"location":"math/mixed/#sumnum","text":"int sumNum(const std::vector<int>& c, int m, int M) \\displaystyle \\text{sumNum}(c, m, M) = \\sum_{\\sum c_i x_i = m} \\frac{(\\sum x_i)!}{\\prod (x_i !)} \\mod M Complexity O(m)","title":"sumNum"},{"location":"math/mixed/#decinc","text":"int decInc(int n, int m) count min time: every time --n or ++m s.t. n \\mid m Complexity O(\\sqrt{m}) Example \\text{decInc}(3, 3) = 0 \\text{decInc}(5, 3) = 2 \\text{decInc}(4, 9) = 1","title":"decInc"},{"location":"math/mixed/#firstinrange","text":"int FirstInRange(int a, int m, int l, int r) finds min x s.t. l \\leq a x \\mod m \\leq r (or -1 if it does not exist) Constraints 0 \\leq l \\leq r < m 0 \\leq a < M Complexity O(\\log m)","title":"FirstInRange"},{"location":"math/mixed/#recseq","text":"template<typename T> // use ModInt, MInt, ModLL class RecSeq : public std::vector<T>; It is used to avoid use matrix multiplication in dp","title":"RecSeq"},{"location":"math/mixed/#gauss","text":"std::vector<double> Gauss(std::vector<std::vector<double>> A, std::vector<double> b) Gauss-Jordan Elimination Ax = b , float version, Inspire by spookywooky Complexity O(n^3)","title":"Gauss"},{"location":"math/mixed/#gaussmodp","text":"std::vector<valT> GaussModp(std::vector<std::vector<valT>> A, std::vector<valT> b) Gauss-Jordan Elimination Ax = b , mod version Complexity O(n^3)","title":"GaussModp"},{"location":"math/mixed/#simplex","text":"using VD = std::vector<double> VD simplex(VD c, std::vector<VD> Aq, VD bq, std::vector<VD> Alq, VD blq) Simplex algorithm for linear programming: compute max cx with constraints: Aq \\cdot x = bq and Alq \\cdot x \\leq blq","title":"simplex"},{"location":"math/mixed/#karatsuba","text":"using VL = std::vector<LL> VL Karatsuba(VL a, VL b, LL p) Polynomial multiplication with arbitrary modulus Complexity O(n^{\\log_2 3}) There is a parallel version of Karatsuba(you may need -lpthread to complier): KaratsubaParallel","title":"Karatsuba"},{"location":"math/mixed/#quadrangleitvdp","text":"std::vector<std::vector<T>> quadrangleItvDp(std::vector<std::vector<T>> w, int n) f_{l, r} = \\min_{l \\leq k < r} f_{l, k} + f_{k + 1, r} + w(l, r) \\qquad (1 \\leq l < r \\leq n) It is a common tech for Segment DP optim: O(n^3) to O(n^2) Complexity O(n^2)","title":"quadrangleItvDp"},{"location":"math/mixed/#quadranglerolldp","text":"std::vector<std::vector<T>> quadrangleRollDp(std::vector<std::vector<T>> w, int n, int m) f_{i, j} = \\min_{k < j} f_{i - 1, k} + w(k + 1, j) \\quad (1 \\leq i \\leq n, 1 \\leq j \\leq m) It is a common tech for oll DP optim: O(n^3) to O(n^2) Complexity O(n m)","title":"quadrangleRollDp"},{"location":"math/mixed/#palindromenumber","text":"It is a singleton class. Recall that n is a Palindrome Number if it's digits representation is a palindrome, for example 1, 121, 33, 23532 are Palindrome Number which 132, 112 are not. LL nthPalindrome(int k) return k -th Palindrome Number. Constraints k < 10^9 Complexity O(\\log k) Example \\text{nthPalindrome}(1) = 1 \\text{nthPalindrome}(10) = 11 \\text{nthPalindrome}(20) = 111 int Palindrome(LL n) return numbers of Palindrome less that n Constraints n < 10^{18} Complexity O(\\log n) Example \\text{Palindrome}(1) = 0 \\text{Palindrome}(111) = 19 LL solve(LL n, int k) { return nthPalindrome(k + Palindrome(n)); } return k -th Palindrome Number greater than or equal to n","title":"PalindromeNumber"},{"location":"math/mixed/#fast-powmod","text":"unsigned fastPowMod998244353(unsigned x, unsigned n); unsigned fastPowMod1000000007(unsigned x, unsigned n); unsigned fastPowMod1000000009(unsigned x, unsigned n); however only fastPowMod998244353 faster than 20%","title":"fast powMod"},{"location":"math/mod/","text":"There are three classes: MInt , ModInt , ModLL . Only MInt is a class template. template<typename valT> (occur in other place) will be one of them. You must assign them a mod before use them. methods Elementary arithmetics: +, -, *, /, +=, -=, *=, /= C-style operator: ++, -- and bit operator <<, <<= raw for constant-factor speedup. pow , >>, << are friend methods. inv is not based on pow , since M is not assume to be prime number. There is no bit operator >> since ((a + M) \\text{>>} x) \\neq (a \\text{>>} x) in general Example #include <bits/stdc++.h> #include \"cpplib/math/mod.hpp\" constexpr int M = 998244353; using mod = MInt<M>; int main() { std::cin.tie(nullptr)->sync_with_stdio(false); int a, b; std::cin >> a >> b; mod a1(a), b1(b); std::cout << a1 + b1 << '\\n'; ModInt::setMod(M); ModInt a2(a), b2(b); std::cout << a2 - b2 << '\\n'; ModLL::setMod(M); ModInt a3(a), b3(b); std::cout << a3 * b3 << '\\n'; std::cout << a3 / b3 << '\\n'; return 0; }","title":"mod"},{"location":"math/mod/#methods","text":"Elementary arithmetics: +, -, *, /, +=, -=, *=, /= C-style operator: ++, -- and bit operator <<, <<= raw for constant-factor speedup. pow , >>, << are friend methods. inv is not based on pow , since M is not assume to be prime number. There is no bit operator >> since ((a + M) \\text{>>} x) \\neq (a \\text{>>} x) in general","title":"methods"},{"location":"math/mod/#example","text":"#include <bits/stdc++.h> #include \"cpplib/math/mod.hpp\" constexpr int M = 998244353; using mod = MInt<M>; int main() { std::cin.tie(nullptr)->sync_with_stdio(false); int a, b; std::cin >> a >> b; mod a1(a), b1(b); std::cout << a1 + b1 << '\\n'; ModInt::setMod(M); ModInt a2(a), b2(b); std::cout << a2 - b2 << '\\n'; ModLL::setMod(M); ModInt a3(a), b3(b); std::cout << a3 * b3 << '\\n'; std::cout << a3 / b3 << '\\n'; return 0; }","title":"Example"},{"location":"math/numberTheory/","text":"numberTheory.hpp p is assume to be a prime number, and M for arbitrary module. please use g++ -o main main.cpp -std=c++17 -O2 to complier examples below. Prime It is a singleton which has member isP, p, pi , and method: primePi and nthPrime \\psi(x,s) = \\sum_{n \\leq x} |\\gcd(n,m_s) == 1| = \\sum_{d \\mid m_s} u(d)\\lfloor \\frac{x}{d} \\rfloor where m_s = p_1 \\cdots p_s The key point is: if s \\geq \\pi(\\sqrt{x}) , then \\psi(x,s) = \\pi(x) - s + 1 See cnblog or origin paper package for detail. Constraints primePi(n): n < N^2 nthPrime(n): n < (\\frac{N}{\\ln n})^2 Complexity primePi(n): O(n^{\\frac{2}{3}}) nthPrime(n): O(n^{\\frac{2}{3}} \\log^2 n) Example #include <bits/stdc++.h> using LL = long long; #include \"cpplib/math/numberTheory.hpp\" int main() { std::cin.tie(nullptr)->sync_with_stdio(false); auto start = std::clock(); auto& prime = Prime::Instance(); std::cerr << \"Init time used: \" << (std::clock() - start) / 1000 << \"ms\" << std::endl; LL n = prime.primePi(123456789012LL); std::cout << n << '\\n'; LL x = prime.nthPrime(n); std::cout << x << '\\n'; // It must the same as n std::cout << prime.primePi(x) << '\\n'; std::cerr << \"Total time used: \" << (std::clock() - start) / 1000 << \"ms\" << std::endl; return 0; } Euler and Mobius Euler's Totient function and Mobius function. The have many in common. The key points are: \\sum_{i = 1}^n \\text{sumPhi}(\\lfloor \\frac{n}{i} \\rfloor) = \\frac{n(n + 1)}{2}, \\quad \\sum_{i = 1}^n \\text{sumMu}(\\lfloor \\frac{n}{i} \\rfloor) = 1 and then numberTheoryBlock tech is used to give a O(n^{\\frac{2}{3}}) implement. Example #include <bits/stdc++.h> #define clog(x) std::clog << (#x) << \" is \" << (x) << '\\n'; using LL = long long; #include \"cpplib/math/numberTheory.hpp\" int main() { std::cin.tie(nullptr)->sync_with_stdio(false); auto start = std::clock(); auto& euler = Euler::Instance(); auto& Mobius = Mobius::Instance(); std::cerr << \"Init time used: \" << (std::clock() - start) / 1000 << \"ms\" << '\\n'; int n = 1e9 + 7; clog(euler.getPhi(n)); clog(euler.getSumPhi(n)); clog(Mobius.getMu(n)); clog(Mobius.getSumMu(n)); clog(Mobius.getAbsSum(n)); std::cerr << \"Total time used: \" << (std::clock() - start) / 1000 << \"ms\" << '\\n'; return 0; } npf std::pair<std::vector<int>, std::vector<int>> npf(int N) // auto [a, b] = npf(N) init numbers of (multi) prime factors less than N Complexity O(N) Example a[4] = 1, b[4] = 2 a[21] = 2, b[21] = 2 a[72] = 2, b[72] = 5 factor and Factor std::vector<int> factor(int n, const std::vector<int>& sp) std::vector<std::pair<int, int>> Factor(int n, const std::vector<int>& sp) factor n into prime number Complexity O(\\log n) Example \\text{factor}(60, sp) = \\{2, 3, 5\\} \\text{Factor}(60, sp) = \\{\\{2, 2\\}, \\{3, 1\\}, \\{5, 1\\}\\} primitiveRoot int primitiveRoot(int n, const std::vector<int>& sp) return smallest primitive root or 0 if not exist. n have primitive root if and only if n = 2, 4, p^n, 2 p^n where p > 2 is prime number. Complexity O(\\log n) Example \\text{primitiveRoot}(998244353) = 3 primitiveRootAll std::vector<int> primitiveRootAll(int n, const std::vector<int>& sp) return list of all primitive roots or empty if not exist Complexity O(n) Example \\text{primitiveRoot}(5) = \\{2, 3\\} PollardRho Pollard-rho algorithm is a probabilistic method for big number decomposition , which is based on big prime test probabilistic method: Miller-Rabin bool PollardRho::rabin(LL n) LL PollardRho::spf(LL n) LL PollardRho::gpf(LL n, LL mxf = 1) Complexity O(n^{\\frac{1}{4}} \\log n) babyStepGiantStep find smallest non-negative x s.t. a^x = b \\mod p , or -1 Constraints p is prime Complexity O(\\sqrt{p} \\log p) sqrtModp int sqrtModp(int a, int p) Constraints p is prime Complexity O(\\log p) lcmPair std::vector<std::tuple<int, int, int>> lcmPair(int n) return all pair (i, j, \\text{lcm}(i, j) with \\text{lcm}(i, j) \\leq n Complexity O(n \\log^2 n) DirichletProduct give two function, f, g , we define Dirichlet Product of f, g as f \\star g defined as (f \\star g)(n) \\doteq \\sum_{d | n} f(d) g(\\frac{n}{d}) g \\equiv 1 , then f \\star g is call Mobius transform, g \\equiv \\mu , then f \\star g is call Mobius inverse transform, where \\mu is mobius function Complexity DirichletProduct: O(n \\log n) Mobius transform: O(n \\log \\log n) Mobius inverse transform: O(n \\log \\log n) DirichletProduct Test // docs/test/math/DirichletTest1.cpp #include <bits/stdc++.h> using LL = long long; #include \"../../cpplib/math/numberTheory.hpp\" using UL = unsigned long long; std::mt19937_64 rnd64(std::chrono::steady_clock::now().time_since_epoch().count()); int main() { std::cin.tie(nullptr)->sync_with_stdio(false); int n = 1e5; std::vector<UL> a(n + 1), e(n + 1, 1), mu(n + 1); e[0] = 0; mu[1] = 1; for (int i = 1; i <= n; ++i) { for (int j = i * 2; j <= n; j += i) { mu[j] -= mu[i]; } } for (int i = 1; i <= n; ++i) a[i] = rnd64(); auto b = a; auto c = DirichletProduct(a, e, n); mobiousTran(a, n); for (int i = 0; i <= n; ++i) assert(a[i] == c[i]); c = DirichletProduct(c, mu, n); mobiousTranInv(a, n); for (int i = 0; i <= n; ++i) assert(a[i] == c[i]); for (int i = 0; i <= n; ++i) assert(a[i] == b[i]); c = DirichletRevProduct(a, e, n); mobiousRevTran(a, n); for (int i = 0; i <= n; ++i) assert(a[i] == c[i]); c = DirichletRevProduct(c, mu, n); mobiousRevTranInv(a, n); for (int i = 0; i <= n; ++i) assert(a[i] == c[i]); for (int i = 0; i <= n; ++i) assert(a[i] == b[i]); return 0; }","title":"numberTheory"},{"location":"math/numberTheory/#numbertheoryhpp","text":"p is assume to be a prime number, and M for arbitrary module. please use g++ -o main main.cpp -std=c++17 -O2 to complier examples below.","title":"numberTheory.hpp"},{"location":"math/numberTheory/#prime","text":"It is a singleton which has member isP, p, pi , and method: primePi and nthPrime \\psi(x,s) = \\sum_{n \\leq x} |\\gcd(n,m_s) == 1| = \\sum_{d \\mid m_s} u(d)\\lfloor \\frac{x}{d} \\rfloor where m_s = p_1 \\cdots p_s The key point is: if s \\geq \\pi(\\sqrt{x}) , then \\psi(x,s) = \\pi(x) - s + 1 See cnblog or origin paper package for detail. Constraints primePi(n): n < N^2 nthPrime(n): n < (\\frac{N}{\\ln n})^2 Complexity primePi(n): O(n^{\\frac{2}{3}}) nthPrime(n): O(n^{\\frac{2}{3}} \\log^2 n)","title":"Prime"},{"location":"math/numberTheory/#example","text":"#include <bits/stdc++.h> using LL = long long; #include \"cpplib/math/numberTheory.hpp\" int main() { std::cin.tie(nullptr)->sync_with_stdio(false); auto start = std::clock(); auto& prime = Prime::Instance(); std::cerr << \"Init time used: \" << (std::clock() - start) / 1000 << \"ms\" << std::endl; LL n = prime.primePi(123456789012LL); std::cout << n << '\\n'; LL x = prime.nthPrime(n); std::cout << x << '\\n'; // It must the same as n std::cout << prime.primePi(x) << '\\n'; std::cerr << \"Total time used: \" << (std::clock() - start) / 1000 << \"ms\" << std::endl; return 0; }","title":"Example"},{"location":"math/numberTheory/#euler-and-mobius","text":"Euler's Totient function and Mobius function. The have many in common. The key points are: \\sum_{i = 1}^n \\text{sumPhi}(\\lfloor \\frac{n}{i} \\rfloor) = \\frac{n(n + 1)}{2}, \\quad \\sum_{i = 1}^n \\text{sumMu}(\\lfloor \\frac{n}{i} \\rfloor) = 1 and then numberTheoryBlock tech is used to give a O(n^{\\frac{2}{3}}) implement.","title":"Euler and Mobius"},{"location":"math/numberTheory/#example_1","text":"#include <bits/stdc++.h> #define clog(x) std::clog << (#x) << \" is \" << (x) << '\\n'; using LL = long long; #include \"cpplib/math/numberTheory.hpp\" int main() { std::cin.tie(nullptr)->sync_with_stdio(false); auto start = std::clock(); auto& euler = Euler::Instance(); auto& Mobius = Mobius::Instance(); std::cerr << \"Init time used: \" << (std::clock() - start) / 1000 << \"ms\" << '\\n'; int n = 1e9 + 7; clog(euler.getPhi(n)); clog(euler.getSumPhi(n)); clog(Mobius.getMu(n)); clog(Mobius.getSumMu(n)); clog(Mobius.getAbsSum(n)); std::cerr << \"Total time used: \" << (std::clock() - start) / 1000 << \"ms\" << '\\n'; return 0; }","title":"Example"},{"location":"math/numberTheory/#npf","text":"std::pair<std::vector<int>, std::vector<int>> npf(int N) // auto [a, b] = npf(N) init numbers of (multi) prime factors less than N Complexity O(N) Example a[4] = 1, b[4] = 2 a[21] = 2, b[21] = 2 a[72] = 2, b[72] = 5","title":"npf"},{"location":"math/numberTheory/#factor-and-factor","text":"std::vector<int> factor(int n, const std::vector<int>& sp) std::vector<std::pair<int, int>> Factor(int n, const std::vector<int>& sp) factor n into prime number Complexity O(\\log n) Example \\text{factor}(60, sp) = \\{2, 3, 5\\} \\text{Factor}(60, sp) = \\{\\{2, 2\\}, \\{3, 1\\}, \\{5, 1\\}\\}","title":"factor and Factor"},{"location":"math/numberTheory/#primitiveroot","text":"int primitiveRoot(int n, const std::vector<int>& sp) return smallest primitive root or 0 if not exist. n have primitive root if and only if n = 2, 4, p^n, 2 p^n where p > 2 is prime number. Complexity O(\\log n)","title":"primitiveRoot"},{"location":"math/numberTheory/#example_2","text":"\\text{primitiveRoot}(998244353) = 3","title":"Example"},{"location":"math/numberTheory/#primitiverootall","text":"std::vector<int> primitiveRootAll(int n, const std::vector<int>& sp) return list of all primitive roots or empty if not exist Complexity O(n)","title":"primitiveRootAll"},{"location":"math/numberTheory/#example_3","text":"\\text{primitiveRoot}(5) = \\{2, 3\\}","title":"Example"},{"location":"math/numberTheory/#pollardrho","text":"Pollard-rho algorithm is a probabilistic method for big number decomposition , which is based on big prime test probabilistic method: Miller-Rabin bool PollardRho::rabin(LL n) LL PollardRho::spf(LL n) LL PollardRho::gpf(LL n, LL mxf = 1) Complexity O(n^{\\frac{1}{4}} \\log n)","title":"PollardRho"},{"location":"math/numberTheory/#babystepgiantstep","text":"find smallest non-negative x s.t. a^x = b \\mod p , or -1 Constraints p is prime Complexity O(\\sqrt{p} \\log p)","title":"babyStepGiantStep"},{"location":"math/numberTheory/#_1","text":"","title":""},{"location":"math/numberTheory/#sqrtmodp","text":"int sqrtModp(int a, int p) Constraints p is prime Complexity O(\\log p)","title":"sqrtModp"},{"location":"math/numberTheory/#lcmpair","text":"std::vector<std::tuple<int, int, int>> lcmPair(int n) return all pair (i, j, \\text{lcm}(i, j) with \\text{lcm}(i, j) \\leq n Complexity O(n \\log^2 n)","title":"lcmPair"},{"location":"math/numberTheory/#dirichletproduct","text":"give two function, f, g , we define Dirichlet Product of f, g as f \\star g defined as (f \\star g)(n) \\doteq \\sum_{d | n} f(d) g(\\frac{n}{d}) g \\equiv 1 , then f \\star g is call Mobius transform, g \\equiv \\mu , then f \\star g is call Mobius inverse transform, where \\mu is mobius function Complexity DirichletProduct: O(n \\log n) Mobius transform: O(n \\log \\log n) Mobius inverse transform: O(n \\log \\log n)","title":"DirichletProduct"},{"location":"math/numberTheory/#dirichletproduct-test","text":"// docs/test/math/DirichletTest1.cpp #include <bits/stdc++.h> using LL = long long; #include \"../../cpplib/math/numberTheory.hpp\" using UL = unsigned long long; std::mt19937_64 rnd64(std::chrono::steady_clock::now().time_since_epoch().count()); int main() { std::cin.tie(nullptr)->sync_with_stdio(false); int n = 1e5; std::vector<UL> a(n + 1), e(n + 1, 1), mu(n + 1); e[0] = 0; mu[1] = 1; for (int i = 1; i <= n; ++i) { for (int j = i * 2; j <= n; j += i) { mu[j] -= mu[i]; } } for (int i = 1; i <= n; ++i) a[i] = rnd64(); auto b = a; auto c = DirichletProduct(a, e, n); mobiousTran(a, n); for (int i = 0; i <= n; ++i) assert(a[i] == c[i]); c = DirichletProduct(c, mu, n); mobiousTranInv(a, n); for (int i = 0; i <= n; ++i) assert(a[i] == c[i]); for (int i = 0; i <= n; ++i) assert(a[i] == b[i]); c = DirichletRevProduct(a, e, n); mobiousRevTran(a, n); for (int i = 0; i <= n; ++i) assert(a[i] == c[i]); c = DirichletRevProduct(c, mu, n); mobiousRevTranInv(a, n); for (int i = 0; i <= n; ++i) assert(a[i] == c[i]); for (int i = 0; i <= n; ++i) assert(a[i] == b[i]); return 0; }","title":"DirichletProduct Test"},{"location":"math/poly/","text":"polyALL.hpp The size: N should be less than 2^{22} \\simeq 4 \\cdot 10^6 , since module used in NTT are only multiples of 2^{23} . poly.hpp support almost every algorithm involved polynomial and the module number M can be any prime number . how to choose There are PolyNTT , PolyFFT , PolyFFTDynamic , PolyMFT provided to suit for different module M . PolyMFT: M > \\text{INT_MAX} PolyFFTDynamic: else if M is uncertain. PolyNTT: else if M is fixed NTT-friendly, such as M = 998244353 or PolyS instead PolyFFT: else PolyOrigin for testing. polyS.hpp PolyS.hpp is a simple and small version of Poly. It contains basic operators: +, -, *, / , log, exp, sqrt, and multi-evaluation for fiexed mod = 998244353. You may change NTTS::M = 998244353 to other NTT-friendly prime number(and primitive root NTTS::g = 3 ). Arbitrary module However M should be bigger than the size N since some function need to assmue 1, \\cdots, N - 1 invertible in \\mod M Two ways to support it. FFT based: you should check if the precision sufficient NTT based: use 3 or 4 or more NTT-friendly modules, are then use Chinese remainder theorem we choose M0 = 595591169, M1 = 645922817, M2 = 897581057, M3 = 998244353 in PolyMFT using following sageMath code: ans = [] for i in range(23, 28): for j in range(1, 1000, 2): if(j * 2 ^i + 1 < 2^30 and is_prime(j*2^i+1) and primitive_root(j*2^i+1) == 3): ans.append(j*2^i+1) for i in sorted(ans): print(i, \"\\t = 1 + \", factor(i-1)) # output: # 167772161 = 1 + 2^25 * 5 # 469762049 = 1 + 2^26 * 7 # 595591169 = 1 + 2^23 * 71 # 645922817 = 1 + 2^23 * 7 * 11 # 897581057 = 1 + 2^23 * 107 # 998244353 = 1 + 2^23 * 7 * 17 Method elementary: +, -, *, /, %, +=, -=, *=, /=, %=, -(negative) , inv, mulXn, modXn, divXn. fundamental: powModPoly, inner, derivation, integral, log, exp, sqrt, mulT, evals, Lagrange, linearRecursion, prod, stirling number(stirling1row, stirling1col, stirling2row, stirling2col) mixed: sin, cos, asin, atan, compose, composeInv, toFallingPowForm, fromFallingPowForm, valToVal prefixPowSum: 1^i + 2^i + \\cdots + (n - 1)^i, 0 < i < k sumFraction: \\sum_{i = 0}^{n - 1} a_i / (1 - b_i x) As an application, we compute n! O(\\sqrt{n} \\log^2 n) and O(\\sqrt{n} \\log n (introduced by min_25) in poly.hpp Example #include <bits/stdc++.h> using LL = long long; #include \"cpplib/math.hpp\" template<typename T> void debug(std::vector<T> a){ for (auto& i : a) std::cout << i << ' '; std::cout << std::endl; } int main() { std::cin.tie(nullptr)->sync_with_stdio(false); std::vector<int> a{1, 2, 3, 4}; std::vector<int> b{1, 2, 3}; PolyS A1(a), B1(b); auto c1 = (A1 * B1).a; debug(c1); using modM = MInt<998244353>; PolyNTT A2(trans<modM>(a)), B2(trans<modM>(b)); auto c2 = (A2 * B2).a; debug(c2); // you must setMod before using it ModInt::setMod(998244353); PolyFFTDynamic A3(trans<ModInt>(a)), B3(trans<ModInt>(b)); auto c3 = (A3 * B3).a; debug(c3); ModLL::setMod(998244353); PolyMFT A4(trans<ModLL>(a)), B4(trans<ModLL>(b)); auto c4 = (A4 * B4).a; debug(c4); return 0; }","title":"poly"},{"location":"math/poly/#polyallhpp","text":"The size: N should be less than 2^{22} \\simeq 4 \\cdot 10^6 , since module used in NTT are only multiples of 2^{23} . poly.hpp support almost every algorithm involved polynomial and the module number M can be any prime number .","title":"polyALL.hpp"},{"location":"math/poly/#how-to-choose","text":"There are PolyNTT , PolyFFT , PolyFFTDynamic , PolyMFT provided to suit for different module M . PolyMFT: M > \\text{INT_MAX} PolyFFTDynamic: else if M is uncertain. PolyNTT: else if M is fixed NTT-friendly, such as M = 998244353 or PolyS instead PolyFFT: else PolyOrigin for testing.","title":"how to choose"},{"location":"math/poly/#polyshpp","text":"PolyS.hpp is a simple and small version of Poly. It contains basic operators: +, -, *, / , log, exp, sqrt, and multi-evaluation for fiexed mod = 998244353. You may change NTTS::M = 998244353 to other NTT-friendly prime number(and primitive root NTTS::g = 3 ).","title":"polyS.hpp"},{"location":"math/poly/#arbitrary-module","text":"However M should be bigger than the size N since some function need to assmue 1, \\cdots, N - 1 invertible in \\mod M Two ways to support it. FFT based: you should check if the precision sufficient NTT based: use 3 or 4 or more NTT-friendly modules, are then use Chinese remainder theorem we choose M0 = 595591169, M1 = 645922817, M2 = 897581057, M3 = 998244353 in PolyMFT using following sageMath code: ans = [] for i in range(23, 28): for j in range(1, 1000, 2): if(j * 2 ^i + 1 < 2^30 and is_prime(j*2^i+1) and primitive_root(j*2^i+1) == 3): ans.append(j*2^i+1) for i in sorted(ans): print(i, \"\\t = 1 + \", factor(i-1)) # output: # 167772161 = 1 + 2^25 * 5 # 469762049 = 1 + 2^26 * 7 # 595591169 = 1 + 2^23 * 71 # 645922817 = 1 + 2^23 * 7 * 11 # 897581057 = 1 + 2^23 * 107 # 998244353 = 1 + 2^23 * 7 * 17","title":"Arbitrary module"},{"location":"math/poly/#method","text":"elementary: +, -, *, /, %, +=, -=, *=, /=, %=, -(negative) , inv, mulXn, modXn, divXn. fundamental: powModPoly, inner, derivation, integral, log, exp, sqrt, mulT, evals, Lagrange, linearRecursion, prod, stirling number(stirling1row, stirling1col, stirling2row, stirling2col) mixed: sin, cos, asin, atan, compose, composeInv, toFallingPowForm, fromFallingPowForm, valToVal prefixPowSum: 1^i + 2^i + \\cdots + (n - 1)^i, 0 < i < k sumFraction: \\sum_{i = 0}^{n - 1} a_i / (1 - b_i x) As an application, we compute n! O(\\sqrt{n} \\log^2 n) and O(\\sqrt{n} \\log n (introduced by min_25) in poly.hpp","title":"Method"},{"location":"math/poly/#example","text":"#include <bits/stdc++.h> using LL = long long; #include \"cpplib/math.hpp\" template<typename T> void debug(std::vector<T> a){ for (auto& i : a) std::cout << i << ' '; std::cout << std::endl; } int main() { std::cin.tie(nullptr)->sync_with_stdio(false); std::vector<int> a{1, 2, 3, 4}; std::vector<int> b{1, 2, 3}; PolyS A1(a), B1(b); auto c1 = (A1 * B1).a; debug(c1); using modM = MInt<998244353>; PolyNTT A2(trans<modM>(a)), B2(trans<modM>(b)); auto c2 = (A2 * B2).a; debug(c2); // you must setMod before using it ModInt::setMod(998244353); PolyFFTDynamic A3(trans<ModInt>(a)), B3(trans<ModInt>(b)); auto c3 = (A3 * B3).a; debug(c3); ModLL::setMod(998244353); PolyMFT A4(trans<ModLL>(a)), B4(trans<ModLL>(b)); auto c4 = (A4 * B4).a; debug(c4); return 0; }","title":"Example"},{"location":"math/primary/","text":"primary.hpp primary.hpp is the foundation of math.hpp . basic.hpp mod.hpp fft.hpp fast Fourier transform It contains dft and idft in namespace FFT . The size of a is a pow of 2 before you use dft(a) or idft(a) ntt.hpp number theory transform It contains dft and idft in template classs NTT . The template M should be NTT-friendly, and size of a is a pow of 2 less that 10^6 before you use dft(a) or idft(a) fmt.hpp fast Mobius transform","title":"primary"},{"location":"math/primary/#primaryhpp","text":"primary.hpp is the foundation of math.hpp .","title":"primary.hpp"},{"location":"math/primary/#basichpp","text":"","title":"basic.hpp"},{"location":"math/primary/#modhpp","text":"","title":"mod.hpp"},{"location":"math/primary/#ffthpp","text":"fast Fourier transform It contains dft and idft in namespace FFT . The size of a is a pow of 2 before you use dft(a) or idft(a)","title":"fft.hpp"},{"location":"math/primary/#ntthpp","text":"number theory transform It contains dft and idft in template classs NTT . The template M should be NTT-friendly, and size of a is a pow of 2 less that 10^6 before you use dft(a) or idft(a)","title":"ntt.hpp"},{"location":"math/primary/#fmthpp","text":"fast Mobius transform","title":"fmt.hpp"}]}