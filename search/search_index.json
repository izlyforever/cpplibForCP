{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Document \u00b6 Useage: C++17 is required, O2 is suggested Categories: math, date structure, graph theory, geometry, mixed Note: algorithm name end with S means simple and slow Index: begin with 0, unless otherwise state commom ideals \u00b6 Dynamic programming Bisection Binary lifting Blocking Divide and Conquer Meet in Middle Small to Large Venice Technique A few words \u00b6 Think twice, code once Talk is cheap, show me the code More is different To be continue...","title":"Introduction"},{"location":"#document","text":"Useage: C++17 is required, O2 is suggested Categories: math, date structure, graph theory, geometry, mixed Note: algorithm name end with S means simple and slow Index: begin with 0, unless otherwise state","title":"Document"},{"location":"#commom-ideals","text":"Dynamic programming Bisection Binary lifting Blocking Divide and Conquer Meet in Middle Small to Large Venice Technique","title":"commom ideals"},{"location":"#a-few-words","text":"Think twice, code once Talk is cheap, show me the code More is different To be continue...","title":"A few words"},{"location":"cn/","text":"\u4ec5\u4e3a\u8865\u5145\uff0c\u8fd9\u91cc\u5c31\u653e\u4e00\u4e2a\u5927\u81f4\u76ee\u5f55\u548c\u4e00\u4e9b\u6838\u5fc3\u5185\u5bb9\u7684\u8bf4\u660e\uff08\u6709\u4e9b\u82f1\u6587\u8bf4\u592a\u9ebb\u70e6\uff09 \u6587\u6863 \u00b6 \u4f7f\u7528\uff1a\u7f16\u8bd1\u5668\u9700\u652f\u6301 C++17\uff0c\u5f3a\u70c8\u5efa\u8bae\u5f00\u542f O2 \u4f18\u5316 \u5206\u7c7b\uff1a\u6570\u5b66\uff0c\u6570\u636e\u7ed3\u6784\uff0c\u5b57\u7b26\u4e32\uff0c\u56fe\u8bba\uff0c\u51e0\u4f55\uff0c\u6742\u7c7b \u7ea6\u5b9a\uff1a\u4ee5 S \u4e3a\u540e\u7f00\u7684\u7b97\u6cd5\u90fd\u662f \u6162\u4e14\u7b80\u5355 \u7684\u7b97\u6cd5\uff0c\uff1f\u8868\u793a\u6682\u672a\u5b9e\u73b0\u3002 \u4e0b\u6807\uff1a\u9ed8\u8ba4\u4ee5 0 \u5f00\u5934\uff0c\u76ee\u524d\u53ea\u6709__\u6811\u72b6\u6570\u7ec4\u548c\u4e00\u4e9b\u6811\u7b97\u6cd5__\u4e3a\u4e86\u65b9\u4fbf\u8d77\u89c1\u4ece 1 \u5f00\u5934\u3002 \u601d\u60f3 \u00b6 \u52a8\u6001\u89c4\u5212 \u4e8c\u5206 \u500d\u589e \u5206\u5757 \u5206\u6cbb \u6c34\u6da8\u8239\u9ad8 \u51b3\u7b56\u5355\u8c03\u6027\u4f18\u5316 Meet in Middle Small to Large \u6570\u5b66 \u00b6 \u57fa\u7840\u6a21\u5757\uff1aprimary.hpp \u00b6 \u6a21\u5feb\u901f\u5e42 \u5411\u4e0a\u53d6\u6574\u548c\u5411\u4e0b\u53d6\u6574 int128 \u8bfb\u5199\uff08\u5feb\u8bfb\uff0cint, long long \u4e5f\u53ef\u4ee5\u4f7f\u7528\uff09 \u4e8c\u8fdb\u5236\u5feb\u901f gcd\uff0c\u62d3\u5c55 gcd \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 CRT \u5e38\u89c4\u4e8c\u9879\u5f0f\u7cfb\u6570\u548c\u6a21\u4e8c\u9879\u5f0f\u7cfb\u6570\uff08\u5355\u4f8b\uff09 Lagrange \u63d2\u503c \u6a21\u81ea\u7136\u6570\u65b9\u5e42\u548c O(k) \u7b97\u6cd5 \u6a21 N \\times N \u77e9\u9635\u4e58\u6cd5\u7c7b\uff08\u7f13\u5b58\u4f18\u5316\uff09 MEX\uff08\u96c6\u5408\u4e2d\u4e0d\u51fa\u73b0\u7684\u6700\u5c0f\u7684\u81ea\u7136\u6570\uff09 \u5feb\u901f\u6392\u5e8f\uff08\u6ca1\u5e26\u968f\u673a\u9009\u62e9\uff0c\u522b\u7528\uff09 \u9884\u5904\u7406\u6700\u5c0f\u7d20\u56e0\u5b50 BerlekampMassey\uff08\u7528\u6765\u627e\u6700\u77ed\u9012\u63a8\u516c\u5f0f\uff09 mod.hpp \u00b6 MInt: \u8fd9\u4e2a\u662f\u7c7b\u6a21\u677f ModInt ModLL FFT.hpp \u00b6 NTT.hpp \u00b6 FMT.hpp \u00b6 \u5feb\u901f Mobius \u53d8\u6362\uff0c\u53eb\u8fd9\u4e2a\u540d\u5b57\u662f\u56e0\u4e3a\u8ddf\u6570\u8bba\u51fd\u6570\u7684 Mobius \u53d8\u6362\u5f62\u5f0f\u4e0a\u4e00\u81f4 \u521d\u7b49\u6570\u8bba\uff1anumberTheory.hpp \u00b6 \u5feb\u901f O(n \\log \\log n) \u7d20\u6570\u7b5b\u548c\u6162\u901f\u7ebf\u6027\u7b5b \u5feb\u901f\u8ba1\u7b97 \\pi(x) \u5feb\u901f\u8ba1\u7b97\u7b2c n \u4e2a\u7d20\u6570\uff08\u4ece 1 \u5f00\u59cb\u6807\u53f7\uff0cp[1] = 2\uff0cp[0] \u65e0\u610f\u4e49\uff09 Euler \u7ebf\u6027\u7b5b Mobius \u7ebf\u6027\u7b5b \u62d3\u5c55\u6b27\u62c9\u5b9a\u7406\uff08\u7ed3\u8bba\u5341\u5206\u7b80\u5355\uff0c\u8bc1\u660e\u9700\u8981\u5206\u89e3\u7d20\u56e0\u5f0f\uff09 min_25 \u7b5b O(n^{\\frac{2}{3}}) \u7b97\u6cd5\u6c42 Euler \u51fd\u6570\u524d\u7f00\u548c\uff0cMobius\uff08\u7edd\u5bf9\u503c\uff09\u524d\u7f00\u548c\uff08\u5185\u542b \u6574\u9664\u5206\u5757\uff09 \u6700\u5c0f\u7d20\u56e0\u5b50\u7ebf\u6027\u7b5b \u9884\u5904\u7406\u7d20\u56e0\u5b50\u4e2a\u6570\uff08\u7b97\u91cd/\u4e0d\u7b97\u91cd\uff09 \u7d20\u56e0\u5b50\u5206\u89e3\uff08\u7b97\u91cd/\u4e0d\u7b97\u91cd\uff09 \u6c42\u539f\u6839 \u5927\u7d20\u6570 Miller-Rabin \u6982\u7387\u5224\u522b\u6cd5 Pollard-Pho \u5927\u6574\u6570\u6700\u5927\u6700\u5c0f\u7d20\u56e0\u5b50\u5206\u89e3 \u6a21\u7d20\u6570\u53d6 log\uff08BabyStepGaintStep\uff09 \u6a21\u7d20\u6570\u5f00\u6839\u53f7 O(log^2 p) \u6a21\u7d20\u6570\u5f00\u6839\u53f7 O(log p) \u7684 Cipolla \u7b97\u6cd5 \u6a21\u5076\u7d20\u6570\u5e42\u5f00\u6839\u53f7\uff1f \u6a21\u5947\u7d20\u6570\u5e42\u5f00\u6839\u53f7\uff1f \u6a21\u4efb\u610f\u6570\u5f00\u6839\u53f7\uff08\u5148\u56e0\u5f0f\u5206\u89e3\uff0c\u770b\u4f5c\u6a21\u7d20\u6570\u65b9\u5f00\u6839\u53f7\uff0c\u518d CRT \u6574\u5408\uff09\uff1f BigInt \uff1f \u00b6 \u6742\u7c7b \u00b6 \u5feb\u901f\u66b4\u529b n \u4e2a\u96c6\u5408\u4e2d\u9009 k \u4e2a\uff0c\u4e8c\u8fdb\u5236\u4e3a 1 \u7684\u8868\u793a\u9009\u62e9 Fibonacci \u6570\u5217 floorSum\uff1a \\displaystyle \\sum_{i = 0}^{n - 1} \\lfloor \\frac{a \\cdot i + b}{m} \\rfloor sumNum\uff1a \\displaystyle \\sum_{\\sum c_i x_i = m} \\frac{(\\sum x_i)!}{\\prod (x_i !)} decInc: \u6bcf\u6b21\u53ef\u9009\u62e9 n \u51cf\u4e00 \u6216 m \u52a0\u4e00\uff0c\u4f7f\u5f97 m \u662f n \u7684\u500d\u6570\u7684\u6700\u5c0f\u6b21\u6570 Gauss \u6d88\u5143\u6cd5\u6d6e\u70b9\u6570\u7248 \u6a21 Gauss \u6d88\u5143\u6cd5 \u7ebf\u6027\u89c4\u5212\u4e4b\u5355\u7eaf\u5f62\u7b97\u6cd5 \u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5 O(n^{\\log_2 3}) \u7684 Karatsuba \u7b97\u6cd5\uff08\u5305\u62ec\u5e76\u884c\u7248\uff09 \u7ebf\u6027\u89c4\u5212 FirstInRange\uff1a\u6c42\u6700\u5c0f\u7684 x \u4f7f\u5f97 l \\leq a x \\mod m \\leq r \u3002\u7c7b\u4f3c exgcd \u7684\u5904\u7406\uff1a\u6c42\u6700\u5c0f\u975e\u8d1f\u6574\u6570 x \u4f7f\u5f97 l \\leq ax - m y \\leq r \u7b49\u4ef7\u4e8e l \\leq (az - m)y - a(yz - x) \\leq r \uff0c\u6ce8\u610f\u5230\u6211\u4eec\u8981\u59cb\u7ec8\u4fdd\u6301 a < m \uff0c\u56e0\u6b64\u5f53 2a > m \u65f6\u9700\u8981\u7279\u5224\u4e00\u4e0b\u3002\u8f6c\u5316\u6210 m - r \\leq (m - a) x - m(x - y - 1) \\leq m - l \u591a\u9879\u5f0f\uff08 \u591a\u9879\u5f0f\u5168\u5bb6\u6876 \u5df2\u5168\u90e8 AC\uff09 \u00b6 \u4ec5\u5305\u542b\u4e58\u6cd5\u7684\u56db\u5927\u591a\u9879\u5f0f\u5e95\u5c42\u57fa\u7c7b\u5206\u522b\u4e3a\uff1aPolyBaseNTT, PolyBaseMFT3(\u5f03\u7528\uff0c\u88ab\u540e\u9762\u4e24\u4e2a\u6dd8\u6c70\u4e86), PolyBaseMFT4, PolyBaseFFT PolyBaseNTT\uff1a\u57fa\u4e8e\u56fa\u5b9a\u7684 NTT-friendly\uff08\u539f\u6839\u4e00\u822c\u4e3a 3\uff09\u6a21\u6570\u5feb\u901f\u6570\u8bba\u53d8\u5316\uff08\u770b\u5177\u4f53\u9898\u76ee\uff0c\u4e00\u822c\u4e3a 998244353\uff09 PolyBaseMFT3\uff1a\u57fa\u4e8e\u4e09\u4e2a\u56fa\u5b9a\u7684 NTT-friendly \u4e14\u539f\u6839\u4e3a 3 \u7684\u4e09\u6a21\u6570\uff08469762049, 998244353, 1004535809\uff09\uff0c\u5229\u7528 crt \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\uff08\u5df2\u88ab\u6dd8\u6c70\uff0c\u8bf7\u52ff\u4f7f\u7528\uff09 PolyBaseMFT4\uff1a\u57fa\u4e8e\u56db\u4e2a\u56fa\u5b9a\u7684 NTT-friendly \u4e14\u539f\u6839\u4e3a 3 \u7684\u56db\u6a21\u6570\uff08595591169, 645922817, 897581057, 998244353\uff09\uff0c\u5229\u7528 crt \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5 PolyBaseFFT\uff1a\u57fa\u4e8e FFT \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\uff08\u9700\u8981\u6ce8\u610f\u7cbe\u5ea6\uff09 \u901a\u8fc7\u6a21\u677f\u7ee7\u627f\u62d3\u5c55\u5f97\u5230\u5168\u9762\u7684\u591a\u9879\u5f0f\u7c7b Poly (\u52a0\u51cf\u4e58\u9664\u4f59\uff0c\u8f6c\u7f6e\u4e58\u6cd5\uff0c\u6c42\u5bfc\uff0c\u79ef\u5206\uff0c\u6307\u6570\uff0c\u5bf9\u6570\uff0c\u6c42\u9006\uff0c\u5f00\u65b9\uff0c\u4e00\u70b9\u6c42\u503c\uff0c\u591a\u70b9\u6c42\u503c\uff0c\u5feb\u901f\u5e42\u6a21\uff0c\u5185\u79ef\uff0c\u4e00\u4e2a\u9996\u4e00\u591a\u9879\u5f0f\u7684\u6b21\u65b9\u6a21 x^n \u5148\u53d6\u5bf9\u6570\u4e58\u4ee5\u6b21\u6570\u518d\u53d6\u6307\u6570\u5f97\u5230\uff0c\u4e09\u89d2\u51fd\u6570\uff0c\u53cd\u4e09\u89d2\u51fd\u6570)\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5b66\u5230\u4e86\u5f88\u591a\u4e1c\u897f \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a O(n \\log^2 n) \u8ba1\u7b97 \\sum_{i = 1}^n \\frac{a_i}{1 - b_i} \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a O(k \\log k \\log n) \u6c42 k \u9636\u5e38\u7cfb\u6570\u9012\u63a8\u516c\u5f0f\u7684\u7b2c n \u9879 \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a\u6a21\u81ea\u7136\u6570\u65b9\u5e42\u548c O(k \\log k) \u5f97\u5230\u524d k \u4e2a\u7b54\u6848 \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1aLagrange \u63d2\u503c\uff1a\u5148\u5206\u6cbb\u6c42 g(x) = \\prod(x - x_i) \uff0c\u518d\u6c42 g'(x) \u5728 x \u5904\u7684\u591a\u70b9\u6c42\u503c\uff0c\u518d\u5206\u6cbb\u5373\u53ef\u3002 \u6c42\u9636\u4e58 n! \\mod p \uff1a\u57fa\u4e8e\u591a\u70b9\u6c42\u503c O(\\sqrt{n} \\log^2 n) \u6c42 \\sqrt{n} \u4e2a\u70b9\u4e4b\u540e\u66b4\u529b \u6c42\u9636\u4e58 n! \\mod p \uff1amin_25 \u7528\u70b9\u6c42\u70b9 O(\\sqrt{n} \\log n) \u6c42 \\sqrt{n} \u4e2a\u70b9\u4e4b\u540e\u66b4\u529b \u65e0\u8fd0\u7b97\u7684\u591a\u9879\u5f0f\u5e95\u5c42\u57fa\u7c7b\uff1aPolyBase\uff08standard \u5728\u53d6\u4f59\u65f6\uff0c\u7279\u522b\u91cd\u8981\u4e0d\u53ef\u7701\u7565\uff09 \u4f7f\u7528\u51c6\u5219 \u00b6 \u591a\u9879\u5f0f\u9879\u6570 N < 4 \\cdot 10^6 M \u8981\u662f\u8d85\u4e86 int\uff0c\u90a3\u5c31\u53ea\u80fd\u7528 ModLL \u7248\u672c 4 \u6a21\u6570 Poly \u5426\u5219\uff0c\u8981\u662f M \u4e0d\u56fa\u5b9a\u5c31\u7528\u4f7f\u7528 ModInt \u7684 FFT \u7248 Poly \u5426\u5219\uff0c\u5f53 M \u4e3a\u56fa\u5b9a\u7684 NTT-friendly \u7d20\u6570\u65f6\uff0c\u4f7f\u7528 NTT \u7248 Poly \u5426\u5219\uff0c\u4f7f\u7528 MInt \u7684 FFT \u7248 Poly \u6781\u7b80\u7248\u591a\u9879\u5f0f\u6a21\u677f\uff08polyS\uff09 \u00b6 \u7531\u4e8e\u591a\u9879\u5f0f\u6a21\u677f\u4e00\u76f4\u6269\u5c55\uff0c\u52a8\u5219 1000+ \u884c\uff0c\u5b9e\u5728\u6709\u70b9\u641e\uff0c\u6240\u4ee5\u5c31\u641e\u4e86\u4e00\u4e2a\u6781\u7b80\u7248\u7684\u3002 \u51e0\u4f55 \u00b6 \u4e8c\u7ef4\u51f8\u5305 \u65cb\u8f6c\u5361\u58f3\uff08\u5f7b\u5e95\u5f04\u61c2\u539f\u7406\uff0c\u4e4b\u540e\u5e94\u7528\u6b64\u539f\u7406\u63a8\u5e7f\u5e94\u7528\u89e3\u51b3\uff1ahttps://www.luogu.com.cn/problem/P7164\uff09 \u5206\u6cbb\u6cd5\u6c42\u5e73\u9762\u6700\u77ed\u8ddd\u79bb k \u7ef4\u504f\u5e8f\u4e4b bitset \u66b4\u529b\u4f18\u5316 O(\\frac{k n^2}{w}) \u56db\u8fb9\u5f62\u4f18\u5316 DP \u56fe\u8bba \u00b6 dfs \u5e8f Euler \u5e8f \u6700\u8fd1\u516c\u5171\u7956\u5148 LCA \u6700\u5c0f\u751f\u6210\u6811 Prim \u6700\u5c0f\u6811\u5f62\u56fe LiuZhu \u62d3\u6251\u6392\u5e8f Euler \u8def Hamilton \u8def\uff1f\uff08NPC \u95ee\u9898\uff0c\u4e0b\u6b21\u4e00\u5b9a\uff09 \u5e26\u8def\u5f84 Floyd \u6700\u77ed\u8def Dijkstra \u6700\u77ed\u8def BellmaFord \u6700\u77ed\u8def SPFA \u8fde\u901a\u5206\u91cf\u4e4b Kosaraju \u7f29\u70b9 \u8fde\u901a\u5206\u91cf\u4e4b 2-SAT \u5272\u70b9\u5272\u8fb9 \u6709\u5411\u56fe S-T \u6700\u5927\u6d41 Dinic O(n^2 m) \u6709\u5411\u56fe S-T \u6700\u5927\u6d41\u7684\u6700\u9ad8\u6807\u53f7\u9884\u6d41\u63a8\u8fdb\u7b97\u6cd5\uff08HLPP\uff09 O(n^2 \\sqrt{m}) \u7b97\u6cd5 \u65e0\u5411\u56fe\u5168\u5c40\u6700\u5c0f\u5272 StoerWagner \u7b97\u6cd5 \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff08\u52bf\u80fd Dijkstra\uff09 \u5b57\u7b26\u4e32 \u00b6 Trie \u666e\u901a\u5b57\u7b26\u4e32\u7248 Trie01 \u6c42\u4e24\u4e24\u5f02\u6216\u6700\u5927\u503c\uff08\u53ef\u5728\u7ebf\uff09 Trie01(FusionTree) \u6c42\u5f02\u6216\u548c\uff08\u652f\u6301\u4fee\u6539\uff0c\u5168\u5c40\u52a0 1\uff09 \u524d\u7f00\u51fd\u6570 \u57fa\u4e8e\u524d\u7f00\u51fd\u6570\u7684 KMP \u7b97\u6cd5 \u57fa\u4e8e\u524d\u7f00\u51fd\u6570\u6c42\u524d\u7f00\u51fa\u73b0\u6b21\u6570 Z-\u51fd\u6570 \u57fa\u4e8e Z-\u51fd\u6570\u7684 KMP \u7b97\u6cd5 AC \u81ea\u52a8\u673a \u540e\u7f00\u6570\u7ec4\u8ba1\u7b97\u7684 O(N) \u8bf1\u5bfc\u6392\u5e8f SA-IS \u7b97\u6cd5 \u6700\u5c0f\u8868\u793a\u6cd5 Lyndon \u5206\u89e3\u7684 Duval \u7b97\u6cd5 \u5904\u7406\u56de\u6587\u7684 Manacher \u7b97\u6cd5 \u6570\u636e\u7ed3\u6784 \u00b6 \u66b4\u529b\u679a\u4e3e \u7ea0\u9519\u7801 \u79bb\u6563\u5316 \u5e76\u67e5\u96c6 (Disjoint Union Set) \u6811\u72b6\u6570\u7ec4 (FenwickTree) \u7ebf\u6bb5\u6811 (Segment Tree) \u53ef\u6301\u7eed\u5316\u7ebf\u6bb5\u6811(Persistable Segment Tree) \u6811\u72b6\u6570\u7ec4\u5957\u7ebf\u6bb5\u6811\u6c42\u52a8\u6001\u533a\u95f4\u7b2c k \u5c0f \u83ab\u961f\uff08\u7ebf\u6bb5\u6811\u4e00\u6837\u90fd\u662f\u901a\u7528\u7684\u7c7b\u578b\uff0c\u5177\u4f53\u95ee\u9898\u5177\u4f53\u5199\uff09 \u6700\u957f\uff08\u4e25\u683c\uff09\u9012\u589e\u5b50\u5e8f\u5217 \u5355\u8c03\u961f\u5217 \u5355\u8c03\u6808 \u7b1b\u5361\u5c14\u6811 \u4e09\u7ef4\u504f\u5e8f\u4e4b\u9648\u4e39\u742a\u5206\u6cbb \u7b2c\u4e8c\u5206\u5757\u5dee\u503c\u7248\uff08\u5728\u7ebf\u7b97\u6cd5\uff0c\u79bb\u7ebf\u53ef\u8282\u7701\u7a7a\u95f4\uff09 \u7b2c\u4e8c\u5206\u5757\u7edd\u5bf9\u503c\u7248\uff08\u5728\u7ebf\u7b97\u6cd5\uff0c\u53ef\u641e\u6210\u5e26\u4fee\u6539\u7248\u672c\uff01\uff09","title":"CN"},{"location":"cn/#_1","text":"\u4f7f\u7528\uff1a\u7f16\u8bd1\u5668\u9700\u652f\u6301 C++17\uff0c\u5f3a\u70c8\u5efa\u8bae\u5f00\u542f O2 \u4f18\u5316 \u5206\u7c7b\uff1a\u6570\u5b66\uff0c\u6570\u636e\u7ed3\u6784\uff0c\u5b57\u7b26\u4e32\uff0c\u56fe\u8bba\uff0c\u51e0\u4f55\uff0c\u6742\u7c7b \u7ea6\u5b9a\uff1a\u4ee5 S \u4e3a\u540e\u7f00\u7684\u7b97\u6cd5\u90fd\u662f \u6162\u4e14\u7b80\u5355 \u7684\u7b97\u6cd5\uff0c\uff1f\u8868\u793a\u6682\u672a\u5b9e\u73b0\u3002 \u4e0b\u6807\uff1a\u9ed8\u8ba4\u4ee5 0 \u5f00\u5934\uff0c\u76ee\u524d\u53ea\u6709__\u6811\u72b6\u6570\u7ec4\u548c\u4e00\u4e9b\u6811\u7b97\u6cd5__\u4e3a\u4e86\u65b9\u4fbf\u8d77\u89c1\u4ece 1 \u5f00\u5934\u3002","title":"\u6587\u6863"},{"location":"cn/#_2","text":"\u52a8\u6001\u89c4\u5212 \u4e8c\u5206 \u500d\u589e \u5206\u5757 \u5206\u6cbb \u6c34\u6da8\u8239\u9ad8 \u51b3\u7b56\u5355\u8c03\u6027\u4f18\u5316 Meet in Middle Small to Large","title":"\u601d\u60f3"},{"location":"cn/#_3","text":"","title":"\u6570\u5b66"},{"location":"cn/#primaryhpp","text":"\u6a21\u5feb\u901f\u5e42 \u5411\u4e0a\u53d6\u6574\u548c\u5411\u4e0b\u53d6\u6574 int128 \u8bfb\u5199\uff08\u5feb\u8bfb\uff0cint, long long \u4e5f\u53ef\u4ee5\u4f7f\u7528\uff09 \u4e8c\u8fdb\u5236\u5feb\u901f gcd\uff0c\u62d3\u5c55 gcd \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 CRT \u5e38\u89c4\u4e8c\u9879\u5f0f\u7cfb\u6570\u548c\u6a21\u4e8c\u9879\u5f0f\u7cfb\u6570\uff08\u5355\u4f8b\uff09 Lagrange \u63d2\u503c \u6a21\u81ea\u7136\u6570\u65b9\u5e42\u548c O(k) \u7b97\u6cd5 \u6a21 N \\times N \u77e9\u9635\u4e58\u6cd5\u7c7b\uff08\u7f13\u5b58\u4f18\u5316\uff09 MEX\uff08\u96c6\u5408\u4e2d\u4e0d\u51fa\u73b0\u7684\u6700\u5c0f\u7684\u81ea\u7136\u6570\uff09 \u5feb\u901f\u6392\u5e8f\uff08\u6ca1\u5e26\u968f\u673a\u9009\u62e9\uff0c\u522b\u7528\uff09 \u9884\u5904\u7406\u6700\u5c0f\u7d20\u56e0\u5b50 BerlekampMassey\uff08\u7528\u6765\u627e\u6700\u77ed\u9012\u63a8\u516c\u5f0f\uff09","title":"\u57fa\u7840\u6a21\u5757\uff1aprimary.hpp"},{"location":"cn/#modhpp","text":"MInt: \u8fd9\u4e2a\u662f\u7c7b\u6a21\u677f ModInt ModLL","title":"mod.hpp"},{"location":"cn/#ffthpp","text":"","title":"FFT.hpp"},{"location":"cn/#ntthpp","text":"","title":"NTT.hpp"},{"location":"cn/#fmthpp","text":"\u5feb\u901f Mobius \u53d8\u6362\uff0c\u53eb\u8fd9\u4e2a\u540d\u5b57\u662f\u56e0\u4e3a\u8ddf\u6570\u8bba\u51fd\u6570\u7684 Mobius \u53d8\u6362\u5f62\u5f0f\u4e0a\u4e00\u81f4","title":"FMT.hpp"},{"location":"cn/#numbertheoryhpp","text":"\u5feb\u901f O(n \\log \\log n) \u7d20\u6570\u7b5b\u548c\u6162\u901f\u7ebf\u6027\u7b5b \u5feb\u901f\u8ba1\u7b97 \\pi(x) \u5feb\u901f\u8ba1\u7b97\u7b2c n \u4e2a\u7d20\u6570\uff08\u4ece 1 \u5f00\u59cb\u6807\u53f7\uff0cp[1] = 2\uff0cp[0] \u65e0\u610f\u4e49\uff09 Euler \u7ebf\u6027\u7b5b Mobius \u7ebf\u6027\u7b5b \u62d3\u5c55\u6b27\u62c9\u5b9a\u7406\uff08\u7ed3\u8bba\u5341\u5206\u7b80\u5355\uff0c\u8bc1\u660e\u9700\u8981\u5206\u89e3\u7d20\u56e0\u5f0f\uff09 min_25 \u7b5b O(n^{\\frac{2}{3}}) \u7b97\u6cd5\u6c42 Euler \u51fd\u6570\u524d\u7f00\u548c\uff0cMobius\uff08\u7edd\u5bf9\u503c\uff09\u524d\u7f00\u548c\uff08\u5185\u542b \u6574\u9664\u5206\u5757\uff09 \u6700\u5c0f\u7d20\u56e0\u5b50\u7ebf\u6027\u7b5b \u9884\u5904\u7406\u7d20\u56e0\u5b50\u4e2a\u6570\uff08\u7b97\u91cd/\u4e0d\u7b97\u91cd\uff09 \u7d20\u56e0\u5b50\u5206\u89e3\uff08\u7b97\u91cd/\u4e0d\u7b97\u91cd\uff09 \u6c42\u539f\u6839 \u5927\u7d20\u6570 Miller-Rabin \u6982\u7387\u5224\u522b\u6cd5 Pollard-Pho \u5927\u6574\u6570\u6700\u5927\u6700\u5c0f\u7d20\u56e0\u5b50\u5206\u89e3 \u6a21\u7d20\u6570\u53d6 log\uff08BabyStepGaintStep\uff09 \u6a21\u7d20\u6570\u5f00\u6839\u53f7 O(log^2 p) \u6a21\u7d20\u6570\u5f00\u6839\u53f7 O(log p) \u7684 Cipolla \u7b97\u6cd5 \u6a21\u5076\u7d20\u6570\u5e42\u5f00\u6839\u53f7\uff1f \u6a21\u5947\u7d20\u6570\u5e42\u5f00\u6839\u53f7\uff1f \u6a21\u4efb\u610f\u6570\u5f00\u6839\u53f7\uff08\u5148\u56e0\u5f0f\u5206\u89e3\uff0c\u770b\u4f5c\u6a21\u7d20\u6570\u65b9\u5f00\u6839\u53f7\uff0c\u518d CRT \u6574\u5408\uff09\uff1f","title":"\u521d\u7b49\u6570\u8bba\uff1anumberTheory.hpp"},{"location":"cn/#bigint","text":"","title":"BigInt \uff1f"},{"location":"cn/#_4","text":"\u5feb\u901f\u66b4\u529b n \u4e2a\u96c6\u5408\u4e2d\u9009 k \u4e2a\uff0c\u4e8c\u8fdb\u5236\u4e3a 1 \u7684\u8868\u793a\u9009\u62e9 Fibonacci \u6570\u5217 floorSum\uff1a \\displaystyle \\sum_{i = 0}^{n - 1} \\lfloor \\frac{a \\cdot i + b}{m} \\rfloor sumNum\uff1a \\displaystyle \\sum_{\\sum c_i x_i = m} \\frac{(\\sum x_i)!}{\\prod (x_i !)} decInc: \u6bcf\u6b21\u53ef\u9009\u62e9 n \u51cf\u4e00 \u6216 m \u52a0\u4e00\uff0c\u4f7f\u5f97 m \u662f n \u7684\u500d\u6570\u7684\u6700\u5c0f\u6b21\u6570 Gauss \u6d88\u5143\u6cd5\u6d6e\u70b9\u6570\u7248 \u6a21 Gauss \u6d88\u5143\u6cd5 \u7ebf\u6027\u89c4\u5212\u4e4b\u5355\u7eaf\u5f62\u7b97\u6cd5 \u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5 O(n^{\\log_2 3}) \u7684 Karatsuba \u7b97\u6cd5\uff08\u5305\u62ec\u5e76\u884c\u7248\uff09 \u7ebf\u6027\u89c4\u5212 FirstInRange\uff1a\u6c42\u6700\u5c0f\u7684 x \u4f7f\u5f97 l \\leq a x \\mod m \\leq r \u3002\u7c7b\u4f3c exgcd \u7684\u5904\u7406\uff1a\u6c42\u6700\u5c0f\u975e\u8d1f\u6574\u6570 x \u4f7f\u5f97 l \\leq ax - m y \\leq r \u7b49\u4ef7\u4e8e l \\leq (az - m)y - a(yz - x) \\leq r \uff0c\u6ce8\u610f\u5230\u6211\u4eec\u8981\u59cb\u7ec8\u4fdd\u6301 a < m \uff0c\u56e0\u6b64\u5f53 2a > m \u65f6\u9700\u8981\u7279\u5224\u4e00\u4e0b\u3002\u8f6c\u5316\u6210 m - r \\leq (m - a) x - m(x - y - 1) \\leq m - l","title":"\u6742\u7c7b"},{"location":"cn/#ac","text":"\u4ec5\u5305\u542b\u4e58\u6cd5\u7684\u56db\u5927\u591a\u9879\u5f0f\u5e95\u5c42\u57fa\u7c7b\u5206\u522b\u4e3a\uff1aPolyBaseNTT, PolyBaseMFT3(\u5f03\u7528\uff0c\u88ab\u540e\u9762\u4e24\u4e2a\u6dd8\u6c70\u4e86), PolyBaseMFT4, PolyBaseFFT PolyBaseNTT\uff1a\u57fa\u4e8e\u56fa\u5b9a\u7684 NTT-friendly\uff08\u539f\u6839\u4e00\u822c\u4e3a 3\uff09\u6a21\u6570\u5feb\u901f\u6570\u8bba\u53d8\u5316\uff08\u770b\u5177\u4f53\u9898\u76ee\uff0c\u4e00\u822c\u4e3a 998244353\uff09 PolyBaseMFT3\uff1a\u57fa\u4e8e\u4e09\u4e2a\u56fa\u5b9a\u7684 NTT-friendly \u4e14\u539f\u6839\u4e3a 3 \u7684\u4e09\u6a21\u6570\uff08469762049, 998244353, 1004535809\uff09\uff0c\u5229\u7528 crt \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\uff08\u5df2\u88ab\u6dd8\u6c70\uff0c\u8bf7\u52ff\u4f7f\u7528\uff09 PolyBaseMFT4\uff1a\u57fa\u4e8e\u56db\u4e2a\u56fa\u5b9a\u7684 NTT-friendly \u4e14\u539f\u6839\u4e3a 3 \u7684\u56db\u6a21\u6570\uff08595591169, 645922817, 897581057, 998244353\uff09\uff0c\u5229\u7528 crt \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5 PolyBaseFFT\uff1a\u57fa\u4e8e FFT \u6c42\u89e3\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\uff08\u9700\u8981\u6ce8\u610f\u7cbe\u5ea6\uff09 \u901a\u8fc7\u6a21\u677f\u7ee7\u627f\u62d3\u5c55\u5f97\u5230\u5168\u9762\u7684\u591a\u9879\u5f0f\u7c7b Poly (\u52a0\u51cf\u4e58\u9664\u4f59\uff0c\u8f6c\u7f6e\u4e58\u6cd5\uff0c\u6c42\u5bfc\uff0c\u79ef\u5206\uff0c\u6307\u6570\uff0c\u5bf9\u6570\uff0c\u6c42\u9006\uff0c\u5f00\u65b9\uff0c\u4e00\u70b9\u6c42\u503c\uff0c\u591a\u70b9\u6c42\u503c\uff0c\u5feb\u901f\u5e42\u6a21\uff0c\u5185\u79ef\uff0c\u4e00\u4e2a\u9996\u4e00\u591a\u9879\u5f0f\u7684\u6b21\u65b9\u6a21 x^n \u5148\u53d6\u5bf9\u6570\u4e58\u4ee5\u6b21\u6570\u518d\u53d6\u6307\u6570\u5f97\u5230\uff0c\u4e09\u89d2\u51fd\u6570\uff0c\u53cd\u4e09\u89d2\u51fd\u6570)\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5b66\u5230\u4e86\u5f88\u591a\u4e1c\u897f \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a O(n \\log^2 n) \u8ba1\u7b97 \\sum_{i = 1}^n \\frac{a_i}{1 - b_i} \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a O(k \\log k \\log n) \u6c42 k \u9636\u5e38\u7cfb\u6570\u9012\u63a8\u516c\u5f0f\u7684\u7b2c n \u9879 \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1a\u6a21\u81ea\u7136\u6570\u65b9\u5e42\u548c O(k \\log k) \u5f97\u5230\u524d k \u4e2a\u7b54\u6848 \u591a\u9879\u5f0f\u9759\u6001\u51fd\u6570\uff1aLagrange \u63d2\u503c\uff1a\u5148\u5206\u6cbb\u6c42 g(x) = \\prod(x - x_i) \uff0c\u518d\u6c42 g'(x) \u5728 x \u5904\u7684\u591a\u70b9\u6c42\u503c\uff0c\u518d\u5206\u6cbb\u5373\u53ef\u3002 \u6c42\u9636\u4e58 n! \\mod p \uff1a\u57fa\u4e8e\u591a\u70b9\u6c42\u503c O(\\sqrt{n} \\log^2 n) \u6c42 \\sqrt{n} \u4e2a\u70b9\u4e4b\u540e\u66b4\u529b \u6c42\u9636\u4e58 n! \\mod p \uff1amin_25 \u7528\u70b9\u6c42\u70b9 O(\\sqrt{n} \\log n) \u6c42 \\sqrt{n} \u4e2a\u70b9\u4e4b\u540e\u66b4\u529b \u65e0\u8fd0\u7b97\u7684\u591a\u9879\u5f0f\u5e95\u5c42\u57fa\u7c7b\uff1aPolyBase\uff08standard \u5728\u53d6\u4f59\u65f6\uff0c\u7279\u522b\u91cd\u8981\u4e0d\u53ef\u7701\u7565\uff09","title":"\u591a\u9879\u5f0f\uff08\u591a\u9879\u5f0f\u5168\u5bb6\u6876 \u5df2\u5168\u90e8 AC\uff09"},{"location":"cn/#_5","text":"\u591a\u9879\u5f0f\u9879\u6570 N < 4 \\cdot 10^6 M \u8981\u662f\u8d85\u4e86 int\uff0c\u90a3\u5c31\u53ea\u80fd\u7528 ModLL \u7248\u672c 4 \u6a21\u6570 Poly \u5426\u5219\uff0c\u8981\u662f M \u4e0d\u56fa\u5b9a\u5c31\u7528\u4f7f\u7528 ModInt \u7684 FFT \u7248 Poly \u5426\u5219\uff0c\u5f53 M \u4e3a\u56fa\u5b9a\u7684 NTT-friendly \u7d20\u6570\u65f6\uff0c\u4f7f\u7528 NTT \u7248 Poly \u5426\u5219\uff0c\u4f7f\u7528 MInt \u7684 FFT \u7248 Poly","title":"\u4f7f\u7528\u51c6\u5219"},{"location":"cn/#polys","text":"\u7531\u4e8e\u591a\u9879\u5f0f\u6a21\u677f\u4e00\u76f4\u6269\u5c55\uff0c\u52a8\u5219 1000+ \u884c\uff0c\u5b9e\u5728\u6709\u70b9\u641e\uff0c\u6240\u4ee5\u5c31\u641e\u4e86\u4e00\u4e2a\u6781\u7b80\u7248\u7684\u3002","title":"\u6781\u7b80\u7248\u591a\u9879\u5f0f\u6a21\u677f\uff08polyS\uff09"},{"location":"cn/#_6","text":"\u4e8c\u7ef4\u51f8\u5305 \u65cb\u8f6c\u5361\u58f3\uff08\u5f7b\u5e95\u5f04\u61c2\u539f\u7406\uff0c\u4e4b\u540e\u5e94\u7528\u6b64\u539f\u7406\u63a8\u5e7f\u5e94\u7528\u89e3\u51b3\uff1ahttps://www.luogu.com.cn/problem/P7164\uff09 \u5206\u6cbb\u6cd5\u6c42\u5e73\u9762\u6700\u77ed\u8ddd\u79bb k \u7ef4\u504f\u5e8f\u4e4b bitset \u66b4\u529b\u4f18\u5316 O(\\frac{k n^2}{w}) \u56db\u8fb9\u5f62\u4f18\u5316 DP","title":"\u51e0\u4f55"},{"location":"cn/#_7","text":"dfs \u5e8f Euler \u5e8f \u6700\u8fd1\u516c\u5171\u7956\u5148 LCA \u6700\u5c0f\u751f\u6210\u6811 Prim \u6700\u5c0f\u6811\u5f62\u56fe LiuZhu \u62d3\u6251\u6392\u5e8f Euler \u8def Hamilton \u8def\uff1f\uff08NPC \u95ee\u9898\uff0c\u4e0b\u6b21\u4e00\u5b9a\uff09 \u5e26\u8def\u5f84 Floyd \u6700\u77ed\u8def Dijkstra \u6700\u77ed\u8def BellmaFord \u6700\u77ed\u8def SPFA \u8fde\u901a\u5206\u91cf\u4e4b Kosaraju \u7f29\u70b9 \u8fde\u901a\u5206\u91cf\u4e4b 2-SAT \u5272\u70b9\u5272\u8fb9 \u6709\u5411\u56fe S-T \u6700\u5927\u6d41 Dinic O(n^2 m) \u6709\u5411\u56fe S-T \u6700\u5927\u6d41\u7684\u6700\u9ad8\u6807\u53f7\u9884\u6d41\u63a8\u8fdb\u7b97\u6cd5\uff08HLPP\uff09 O(n^2 \\sqrt{m}) \u7b97\u6cd5 \u65e0\u5411\u56fe\u5168\u5c40\u6700\u5c0f\u5272 StoerWagner \u7b97\u6cd5 \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff08\u52bf\u80fd Dijkstra\uff09","title":"\u56fe\u8bba"},{"location":"cn/#_8","text":"Trie \u666e\u901a\u5b57\u7b26\u4e32\u7248 Trie01 \u6c42\u4e24\u4e24\u5f02\u6216\u6700\u5927\u503c\uff08\u53ef\u5728\u7ebf\uff09 Trie01(FusionTree) \u6c42\u5f02\u6216\u548c\uff08\u652f\u6301\u4fee\u6539\uff0c\u5168\u5c40\u52a0 1\uff09 \u524d\u7f00\u51fd\u6570 \u57fa\u4e8e\u524d\u7f00\u51fd\u6570\u7684 KMP \u7b97\u6cd5 \u57fa\u4e8e\u524d\u7f00\u51fd\u6570\u6c42\u524d\u7f00\u51fa\u73b0\u6b21\u6570 Z-\u51fd\u6570 \u57fa\u4e8e Z-\u51fd\u6570\u7684 KMP \u7b97\u6cd5 AC \u81ea\u52a8\u673a \u540e\u7f00\u6570\u7ec4\u8ba1\u7b97\u7684 O(N) \u8bf1\u5bfc\u6392\u5e8f SA-IS \u7b97\u6cd5 \u6700\u5c0f\u8868\u793a\u6cd5 Lyndon \u5206\u89e3\u7684 Duval \u7b97\u6cd5 \u5904\u7406\u56de\u6587\u7684 Manacher \u7b97\u6cd5","title":"\u5b57\u7b26\u4e32"},{"location":"cn/#_9","text":"\u66b4\u529b\u679a\u4e3e \u7ea0\u9519\u7801 \u79bb\u6563\u5316 \u5e76\u67e5\u96c6 (Disjoint Union Set) \u6811\u72b6\u6570\u7ec4 (FenwickTree) \u7ebf\u6bb5\u6811 (Segment Tree) \u53ef\u6301\u7eed\u5316\u7ebf\u6bb5\u6811(Persistable Segment Tree) \u6811\u72b6\u6570\u7ec4\u5957\u7ebf\u6bb5\u6811\u6c42\u52a8\u6001\u533a\u95f4\u7b2c k \u5c0f \u83ab\u961f\uff08\u7ebf\u6bb5\u6811\u4e00\u6837\u90fd\u662f\u901a\u7528\u7684\u7c7b\u578b\uff0c\u5177\u4f53\u95ee\u9898\u5177\u4f53\u5199\uff09 \u6700\u957f\uff08\u4e25\u683c\uff09\u9012\u589e\u5b50\u5e8f\u5217 \u5355\u8c03\u961f\u5217 \u5355\u8c03\u6808 \u7b1b\u5361\u5c14\u6811 \u4e09\u7ef4\u504f\u5e8f\u4e4b\u9648\u4e39\u742a\u5206\u6cbb \u7b2c\u4e8c\u5206\u5757\u5dee\u503c\u7248\uff08\u5728\u7ebf\u7b97\u6cd5\uff0c\u79bb\u7ebf\u53ef\u8282\u7701\u7a7a\u95f4\uff09 \u7b2c\u4e8c\u5206\u5757\u7edd\u5bf9\u503c\u7248\uff08\u5728\u7ebf\u7b97\u6cd5\uff0c\u53ef\u641e\u6210\u5e26\u4fee\u6539\u7248\u672c\uff01\uff09","title":"\u6570\u636e\u7ed3\u6784"},{"location":"dataStructure/","text":"dataStructure.hpp \u00b6 Data Structures are ideals or models, It is hard to write once, used everywhere, for example, Segment Tree, Disjoint set union, Mo's algorithm , monicDeque, monicStack. We will provide some Frames (you should implement it to meet for needs) method \u00b6 nextBinom \u00b6 Just the same as next_permutation to bruteForce all permutation, we have nextBinom to bruteForce all Binom. for example bruteForceBinom(2, 4) will get 0 1 0 2 0 3 1 2 1 3 2 3 and It can be used in ECC discrete \u00b6 #include <bits/stdc++.h> #define clog(x) std::clog << (#x) << \" is \" << (x) << '\\n'; using LL = long long ; #include \"cpplib/all.hpp\" int main () { // freopen(\"in\", \"r\", stdin); std :: cin . tie ( nullptr ) -> sync_with_stdio ( false ); std :: vector < int > a { -12 , 232 , 12 , 23 }; auto b = discrete ( a ); for ( auto & x : a ) std :: cout << x << ' ' ; std :: cout << '\\n' ; for ( auto & x : b ) std :: cout << x << ' ' ; std :: cout << '\\n' ; return 0 ; } // output: // 0 3 1 2 // -12 12 23 232 DSU: Disjoint Set Union \u00b6 Bit tree \u00b6 BitreeMin: min version Bitree: origin version(provide binary search) BitreePlus: plus version(support segment add) SegmentTree \u00b6 There are two versions: sum and min/max min/max version slightly hard: you should record min/max , and second min/max value: https://codeforces.com/gym/102992/problem/J Persistent Segment Tree \u00b6 It save all version of update, and version number are saved in roots . Is this data structure used in Git ? BitPstSegTree \u00b6 Bitree inside a Persistent Segment Tree to get dynamic k-th smallest number(online algorithm) subsequence \u00b6 LIS: length of longest increasing subsquence LNDS: length of longest non-decreasing subsquence LISP: (one of) longest increasing subsquence Cartesian Tree \u00b6 CDQ divided and conquer \u00b6 second Block \u00b6","title":"Data Structure"},{"location":"dataStructure/#datastructurehpp","text":"Data Structures are ideals or models, It is hard to write once, used everywhere, for example, Segment Tree, Disjoint set union, Mo's algorithm , monicDeque, monicStack. We will provide some Frames (you should implement it to meet for needs)","title":"dataStructure.hpp"},{"location":"dataStructure/#method","text":"","title":"method"},{"location":"dataStructure/#nextbinom","text":"Just the same as next_permutation to bruteForce all permutation, we have nextBinom to bruteForce all Binom. for example bruteForceBinom(2, 4) will get 0 1 0 2 0 3 1 2 1 3 2 3 and It can be used in ECC","title":"nextBinom"},{"location":"dataStructure/#discrete","text":"#include <bits/stdc++.h> #define clog(x) std::clog << (#x) << \" is \" << (x) << '\\n'; using LL = long long ; #include \"cpplib/all.hpp\" int main () { // freopen(\"in\", \"r\", stdin); std :: cin . tie ( nullptr ) -> sync_with_stdio ( false ); std :: vector < int > a { -12 , 232 , 12 , 23 }; auto b = discrete ( a ); for ( auto & x : a ) std :: cout << x << ' ' ; std :: cout << '\\n' ; for ( auto & x : b ) std :: cout << x << ' ' ; std :: cout << '\\n' ; return 0 ; } // output: // 0 3 1 2 // -12 12 23 232","title":"discrete"},{"location":"dataStructure/#dsu-disjoint-set-union","text":"","title":"DSU: Disjoint Set Union"},{"location":"dataStructure/#bit-tree","text":"BitreeMin: min version Bitree: origin version(provide binary search) BitreePlus: plus version(support segment add)","title":"Bit tree"},{"location":"dataStructure/#segmenttree","text":"There are two versions: sum and min/max min/max version slightly hard: you should record min/max , and second min/max value: https://codeforces.com/gym/102992/problem/J","title":"SegmentTree"},{"location":"dataStructure/#persistent-segment-tree","text":"It save all version of update, and version number are saved in roots . Is this data structure used in Git ?","title":"Persistent Segment Tree"},{"location":"dataStructure/#bitpstsegtree","text":"Bitree inside a Persistent Segment Tree to get dynamic k-th smallest number(online algorithm)","title":"BitPstSegTree"},{"location":"dataStructure/#subsequence","text":"LIS: length of longest increasing subsquence LNDS: length of longest non-decreasing subsquence LISP: (one of) longest increasing subsquence","title":"subsequence"},{"location":"dataStructure/#cartesian-tree","text":"","title":"Cartesian Tree"},{"location":"dataStructure/#cdq-divided-and-conquer","text":"","title":"CDQ divided and conquer"},{"location":"dataStructure/#second-block","text":"","title":"second Block"},{"location":"graph/","text":"graph.hpp \u00b6 Tree \u00b6 DfsTour EulerTour LCA Prim: Minimum Spanning Tree LiuZhu: Minimum tree diagram TopSort EulerPath link/cut Tree , dsu on tree need case-by-case analysis. Shortest Path \u00b6 Floyd BellmanFord spfa Scc: Strongly Connected Components twoSAT cutVertex CutEdge Flow \u00b6 Dinic: S-T max-Flow O(n^2 m) HLPP: S-T max-Flow O(n^2 \\sqrt{m}) Stoer-Wagner: Global minimum cut of undirected graph( O(n^3) implement) Flow: minimum cost maximum flow","title":"Graph Theory"},{"location":"graph/#graphhpp","text":"","title":"graph.hpp"},{"location":"graph/#tree","text":"DfsTour EulerTour LCA Prim: Minimum Spanning Tree LiuZhu: Minimum tree diagram TopSort EulerPath link/cut Tree , dsu on tree need case-by-case analysis.","title":"Tree"},{"location":"graph/#shortest-path","text":"Floyd BellmanFord spfa Scc: Strongly Connected Components twoSAT cutVertex CutEdge","title":"Shortest Path"},{"location":"graph/#flow","text":"Dinic: S-T max-Flow O(n^2 m) HLPP: S-T max-Flow O(n^2 \\sqrt{m}) Stoer-Wagner: Global minimum cut of undirected graph( O(n^3) implement) Flow: minimum cost maximum flow","title":"Flow"},{"location":"string/","text":"string.hpp \u00b6 Tire \u00b6 Trie: build a Trie Trie01: find max xor sum FusionTree: special Trie01, get xor sum(support modifty, add 1 to all) KMP \u00b6 prefixFunction kmp countPrefix zFunction kmpZ Automaton \u00b6 Suffix array \u00b6 minPresent \u00b6 Lyndon decomposition \u00b6 Palindrome \u00b6","title":"String"},{"location":"string/#stringhpp","text":"","title":"string.hpp"},{"location":"string/#tire","text":"Trie: build a Trie Trie01: find max xor sum FusionTree: special Trie01, get xor sum(support modifty, add 1 to all)","title":"Tire"},{"location":"string/#kmp","text":"prefixFunction kmp countPrefix zFunction kmpZ","title":"KMP"},{"location":"string/#automaton","text":"","title":"Automaton"},{"location":"string/#suffix-array","text":"","title":"Suffix array"},{"location":"string/#minpresent","text":"","title":"minPresent"},{"location":"string/#lyndon-decomposition","text":"","title":"Lyndon decomposition"},{"location":"string/#palindrome","text":"","title":"Palindrome"},{"location":"math/geometry/","text":"geometry.hpp \u00b6 It contains elementary method for geometry cross: cross product crossLeft: check if cross product is postive dist dist2: square of dist convexHull diameter minDist partialOrder: partial order of dimension k(optimed by bitset)","title":"geometry"},{"location":"math/geometry/#geometryhpp","text":"It contains elementary method for geometry cross: cross product crossLeft: check if cross product is postive dist dist2: square of dist convexHull diameter minDist partialOrder: partial order of dimension k(optimed by bitset)","title":"geometry.hpp"},{"location":"math/mixed/","text":"mixed.hpp \u00b6 GospersHack: n choose k, brute-force(you should implement it to meet for needs) n -th Fibonacci number floorSum: \\displaystyle \\sum_{i = 0}^{n - 1} \\lfloor \\frac{a \\cdot i + b}{m} \\rfloor sumNum: \\displaystyle \\sum_{\\sum c_i x_i = m} \\frac{(\\sum x_i)!}{\\prod (x_i !)} decInc: count min time: every time --n or ++m s.t. n \\mid m FirstInRange: finds min x s.t. L \\leq (A x) \\mod M \\leq R (or -1 if it does not exist) Gauss: Gauss-Jordan Elimination Ax = b , float version GaussModp: Gauss-Jordan Elimination Ax = b , mod version simplex: Simplex algorithm for linear programming Karatsuba: Polynomial multiplication with arbitrary modulus O(n^{\\log_2 3}) KaratsubaParallel: parallel version of Karatsuba(you may need -lpthread to complier) quadrangleItvDp: Segment DP optim: O(n^3) to O(n^2) quadrangleRollDp: roll DP optim O(n^3) to O(n^2)","title":"mixed"},{"location":"math/mixed/#mixedhpp","text":"GospersHack: n choose k, brute-force(you should implement it to meet for needs) n -th Fibonacci number floorSum: \\displaystyle \\sum_{i = 0}^{n - 1} \\lfloor \\frac{a \\cdot i + b}{m} \\rfloor sumNum: \\displaystyle \\sum_{\\sum c_i x_i = m} \\frac{(\\sum x_i)!}{\\prod (x_i !)} decInc: count min time: every time --n or ++m s.t. n \\mid m FirstInRange: finds min x s.t. L \\leq (A x) \\mod M \\leq R (or -1 if it does not exist) Gauss: Gauss-Jordan Elimination Ax = b , float version GaussModp: Gauss-Jordan Elimination Ax = b , mod version simplex: Simplex algorithm for linear programming Karatsuba: Polynomial multiplication with arbitrary modulus O(n^{\\log_2 3}) KaratsubaParallel: parallel version of Karatsuba(you may need -lpthread to complier) quadrangleItvDp: Segment DP optim: O(n^3) to O(n^2) quadrangleRollDp: roll DP optim O(n^3) to O(n^2)","title":"mixed.hpp"},{"location":"math/numberTheory/","text":"numberTheory.hpp \u00b6 please use g++ -o main main.cpp -std=c++17 -O2 to complier examples below. Prime \u00b6 It is a singleton which has member isP, p, pi , and method: primePi and nthPrime \\psi(x,s) = \\sum_{n \\leq x} |\\gcd(n,m_s) == 1| = \\sum_{d \\mid m_s} u(d)\\lfloor \\frac{x}{d} \\rfloor where m_s = p_1 \\cdots p_s The key point is: if s \\geq \\pi(\\sqrt{x}) , then \\psi(x,s) = \\pi(x) - s + 1 See cnblog or origin paper package for detail. Example \u00b6 #include <bits/stdc++.h> #define clog(x) std::clog << (#x) << \" is \" << (x) << '\\n'; using LL = long long ; #include \"cpplib/math/numberTheory.hpp\" int main () { //freopen(\"in\", \"r\", stdin); std :: cin . tie ( nullptr ) -> sync_with_stdio ( false ); auto start = std :: clock (); auto & prime = Prime :: Instance (); std :: clog << \"Init time used: \" << ( std :: clock () - start ) / 1000 << \"ms\" << std :: endl ; LL n = prime . primePi ( 123456789012L L ); std :: cout << n << '\\n' ; LL x = prime . nthPrime ( n ); std :: cout << x << '\\n' ; // It must the same as n std :: cout << prime . primePi ( x ) << '\\n' ; std :: clog << \"Total time used: \" << ( std :: clock () - start ) / 1000 << \"ms\" << std :: endl ; return 0 ; } Euler and Mobious \u00b6 Euler's Totient function and Mobious function. The have many in common. The key points are: \\sum_{i = 1}^n \\text{sumPhi}(\\lfloor \\frac{n}{i} \\rfloor) = \\frac{n(n + 1)}{2}, \\quad \\sum_{i = 1}^n \\text{sumMu}(\\lfloor \\frac{n}{i} \\rfloor) = 1 and then numberTheoryBlock tech is used to give a O(n^{\\frac{2}{3}}) implement. Example \u00b6 #include <bits/stdc++.h> #define clog(x) std::clog << (#x) << \" is \" << (x) << '\\n'; using LL = long long ; #include \"cpplib/math/numberTheory.hpp\" int main () { //freopen(\"in\", \"r\", stdin); std :: cin . tie ( nullptr ) -> sync_with_stdio ( false ); auto start = std :: clock (); auto & euler = Euler :: Instance (); auto & mobious = Mobious :: Instance (); std :: clog << \"Init time used: \" << ( std :: clock () - start ) / 1000 << \"ms\" << std :: endl ; int n = 1e9 + 7 ; clog ( euler . getPhi ( n )); clog ( euler . getSumPhi ( n )); clog ( mobious . getMu ( n )); clog ( mobious . getSumMu ( n )); clog ( mobious . getAbsSum ( n )); std :: clog << \"Total time used: \" << ( std :: clock () - start ) / 1000 << \"ms\" << std :: endl ; return 0 ; } others \u00b6 npf: init numbers of (multi) prime factors less than N in O(N) factor: list of different prime factors of n Factor: list of prime factors of n primitiveRoot: smallest primitive root or 0 primitiveRootAll: list of all primitive roots or empty PollardRho: Probabilistic Method: Miller-Rabin prime test and PollardRho big number Decomposition babyStepGiantStep: find smallest non-negetive x s.t. a^x = b \\mod p , or -1 sqrtModp: find x s.t. x^2 = a \\mod p , or -1 in O(\\log^2 p)","title":"numberTheory"},{"location":"math/numberTheory/#numbertheoryhpp","text":"please use g++ -o main main.cpp -std=c++17 -O2 to complier examples below.","title":"numberTheory.hpp"},{"location":"math/numberTheory/#prime","text":"It is a singleton which has member isP, p, pi , and method: primePi and nthPrime \\psi(x,s) = \\sum_{n \\leq x} |\\gcd(n,m_s) == 1| = \\sum_{d \\mid m_s} u(d)\\lfloor \\frac{x}{d} \\rfloor where m_s = p_1 \\cdots p_s The key point is: if s \\geq \\pi(\\sqrt{x}) , then \\psi(x,s) = \\pi(x) - s + 1 See cnblog or origin paper package for detail.","title":"Prime"},{"location":"math/numberTheory/#example","text":"#include <bits/stdc++.h> #define clog(x) std::clog << (#x) << \" is \" << (x) << '\\n'; using LL = long long ; #include \"cpplib/math/numberTheory.hpp\" int main () { //freopen(\"in\", \"r\", stdin); std :: cin . tie ( nullptr ) -> sync_with_stdio ( false ); auto start = std :: clock (); auto & prime = Prime :: Instance (); std :: clog << \"Init time used: \" << ( std :: clock () - start ) / 1000 << \"ms\" << std :: endl ; LL n = prime . primePi ( 123456789012L L ); std :: cout << n << '\\n' ; LL x = prime . nthPrime ( n ); std :: cout << x << '\\n' ; // It must the same as n std :: cout << prime . primePi ( x ) << '\\n' ; std :: clog << \"Total time used: \" << ( std :: clock () - start ) / 1000 << \"ms\" << std :: endl ; return 0 ; }","title":"Example"},{"location":"math/numberTheory/#euler-and-mobious","text":"Euler's Totient function and Mobious function. The have many in common. The key points are: \\sum_{i = 1}^n \\text{sumPhi}(\\lfloor \\frac{n}{i} \\rfloor) = \\frac{n(n + 1)}{2}, \\quad \\sum_{i = 1}^n \\text{sumMu}(\\lfloor \\frac{n}{i} \\rfloor) = 1 and then numberTheoryBlock tech is used to give a O(n^{\\frac{2}{3}}) implement.","title":"Euler and Mobious"},{"location":"math/numberTheory/#example_1","text":"#include <bits/stdc++.h> #define clog(x) std::clog << (#x) << \" is \" << (x) << '\\n'; using LL = long long ; #include \"cpplib/math/numberTheory.hpp\" int main () { //freopen(\"in\", \"r\", stdin); std :: cin . tie ( nullptr ) -> sync_with_stdio ( false ); auto start = std :: clock (); auto & euler = Euler :: Instance (); auto & mobious = Mobious :: Instance (); std :: clog << \"Init time used: \" << ( std :: clock () - start ) / 1000 << \"ms\" << std :: endl ; int n = 1e9 + 7 ; clog ( euler . getPhi ( n )); clog ( euler . getSumPhi ( n )); clog ( mobious . getMu ( n )); clog ( mobious . getSumMu ( n )); clog ( mobious . getAbsSum ( n )); std :: clog << \"Total time used: \" << ( std :: clock () - start ) / 1000 << \"ms\" << std :: endl ; return 0 ; }","title":"Example"},{"location":"math/numberTheory/#others","text":"npf: init numbers of (multi) prime factors less than N in O(N) factor: list of different prime factors of n Factor: list of prime factors of n primitiveRoot: smallest primitive root or 0 primitiveRootAll: list of all primitive roots or empty PollardRho: Probabilistic Method: Miller-Rabin prime test and PollardRho big number Decomposition babyStepGiantStep: find smallest non-negetive x s.t. a^x = b \\mod p , or -1 sqrtModp: find x s.t. x^2 = a \\mod p , or -1 in O(\\log^2 p)","title":"others"},{"location":"math/poly/","text":"polyALL.hpp \u00b6 The size: N should be less than 10^6 or 2^{22} \\doteq 4 \\cdot 10^6 at least. poly.hpp support almost every algorithm involved polynomial and the module number M can be any prime number . how to choose \u00b6 There are PolyNTT , PolyFFT , PolyFFTDynamic , PolyMFT provided to suit for different module M . PolyMFT: M > \\text{INT_MAX} PolyFFTDynamic: else if M is uncertain. PolyNTT: else if M is fixed NTT-friendly, such as M = 998244353 or PolyS instead PolyFFT: else PolyOrigin for testing. polyS.hpp \u00b6 PolyS.hpp is a simple and small version of Poly. It contains basic operators: +, -, *, / , log, exp, sqrt, and multi-evaluation for fiexed mod = 998244353. You may change NTTS::M = 998244353 to other NTT-friendly prime number(and primitive root NTTS::g = 3 ). Arbitrary module \u00b6 However M should be bigger than the size N since some function need to assmue 1, \\cdots, N - 1 invertible in \\mod M Two ways to support it. FFT based: you should check if the precision sufficient NTT based: use 3 or 4 or more NTT-friendly modules, are then use Chinese remainder theorem we choose M0 = 595591169, M1 = 645922817, M2 = 897581057, M3 = 998244353 in PolyMFT using following sageMath code: ans = [] for i in range ( 23 , 28 ): for j in range ( 1 , 1000 , 2 ): if ( j * 2 ^ i + 1 < 2 ^ 30 and is_prime ( j * 2 ^ i + 1 ) and primitive_root ( j * 2 ^ i + 1 ) == 3 ): ans . append ( j * 2 ^ i + 1 ) for i in sorted ( ans ): print ( i , \" \\t = 1 + \" , factor ( i - 1 )) # output: # 167772161 = 1 + 2^25 * 5 # 469762049 = 1 + 2^26 * 7 # 595591169 = 1 + 2^23 * 71 # 645922817 = 1 + 2^23 * 7 * 11 # 897581057 = 1 + 2^23 * 107 # 998244353 = 1 + 2^23 * 7 * 17 Method \u00b6 elementary: +, -, *, /, %, +=, -=, *=, /=, %=, -(negetive) , inv, mulXn, modXn, divXn. fundamental: powModPoly, inner, derivation, integral, log, exp, sqrt, mulT, evals, Lagrange, linearRecursion, prod, stirling number(stirling1row, stirling1col, stirling2row, stirling2col) mixed: sin, cos, asin, atan, compose, composeInv, toFallingPowForm, fromFallingPowForm, valToVal prefixPowSum: 1^i + 2^i + \\cdots + (n - 1)^i, 0 < i < k sumFraction: \\sum_{i = 0}^{n - 1} a_i / (1 - b_i x) As an application, we compute n! O(\\sqrt{n} \\log^2 n) and O(\\sqrt{n} \\log n (introduced by min_25) in poly.hpp Example \u00b6 #include <bits/stdc++.h> #define clog(x) std::clog << (#x) << \" is \" << (x) << '\\n'; using LL = long long ; #include \"cpplib/math.hpp\" template < typename T > void debug ( std :: vector < T > a ){ for ( auto & i : a ) std :: cout << i << ' ' ; std :: cout << std :: endl ; } int main () { //freopen(\"in\", \"r\", stdin); std :: cin . tie ( nullptr ) -> sync_with_stdio ( false ); std :: vector < int > a { 1 , 2 , 3 , 4 }; std :: vector < int > b { 1 , 2 , 3 }; PolyS A1 ( a ), B1 ( b ); auto c1 = ( A1 * B1 ). a ; debug ( c1 ); using modM = MInt < 998244353 > ; PolyNTT A2 ( trans < modM > ( a )), B2 ( trans < modM > ( b )); auto c2 = ( A2 * B2 ). a ; debug ( c2 ); // you must setMod before using it ModInt :: setMod ( 998244353 ); PolyFFTDynamic A3 ( trans < ModInt > ( a )), B3 ( trans < ModInt > ( b )); auto c3 = ( A3 * B3 ). a ; debug ( c3 ); ModLL :: setMod ( 998244353 ); PolyMFT A4 ( trans < ModLL > ( a )), B4 ( trans < ModLL > ( b )); auto c4 = ( A4 * B4 ). a ; debug ( c4 ); return 0 ; }","title":"poly"},{"location":"math/poly/#polyallhpp","text":"The size: N should be less than 10^6 or 2^{22} \\doteq 4 \\cdot 10^6 at least. poly.hpp support almost every algorithm involved polynomial and the module number M can be any prime number .","title":"polyALL.hpp"},{"location":"math/poly/#how-to-choose","text":"There are PolyNTT , PolyFFT , PolyFFTDynamic , PolyMFT provided to suit for different module M . PolyMFT: M > \\text{INT_MAX} PolyFFTDynamic: else if M is uncertain. PolyNTT: else if M is fixed NTT-friendly, such as M = 998244353 or PolyS instead PolyFFT: else PolyOrigin for testing.","title":"how to choose"},{"location":"math/poly/#polyshpp","text":"PolyS.hpp is a simple and small version of Poly. It contains basic operators: +, -, *, / , log, exp, sqrt, and multi-evaluation for fiexed mod = 998244353. You may change NTTS::M = 998244353 to other NTT-friendly prime number(and primitive root NTTS::g = 3 ).","title":"polyS.hpp"},{"location":"math/poly/#arbitrary-module","text":"However M should be bigger than the size N since some function need to assmue 1, \\cdots, N - 1 invertible in \\mod M Two ways to support it. FFT based: you should check if the precision sufficient NTT based: use 3 or 4 or more NTT-friendly modules, are then use Chinese remainder theorem we choose M0 = 595591169, M1 = 645922817, M2 = 897581057, M3 = 998244353 in PolyMFT using following sageMath code: ans = [] for i in range ( 23 , 28 ): for j in range ( 1 , 1000 , 2 ): if ( j * 2 ^ i + 1 < 2 ^ 30 and is_prime ( j * 2 ^ i + 1 ) and primitive_root ( j * 2 ^ i + 1 ) == 3 ): ans . append ( j * 2 ^ i + 1 ) for i in sorted ( ans ): print ( i , \" \\t = 1 + \" , factor ( i - 1 )) # output: # 167772161 = 1 + 2^25 * 5 # 469762049 = 1 + 2^26 * 7 # 595591169 = 1 + 2^23 * 71 # 645922817 = 1 + 2^23 * 7 * 11 # 897581057 = 1 + 2^23 * 107 # 998244353 = 1 + 2^23 * 7 * 17","title":"Arbitrary module"},{"location":"math/poly/#method","text":"elementary: +, -, *, /, %, +=, -=, *=, /=, %=, -(negetive) , inv, mulXn, modXn, divXn. fundamental: powModPoly, inner, derivation, integral, log, exp, sqrt, mulT, evals, Lagrange, linearRecursion, prod, stirling number(stirling1row, stirling1col, stirling2row, stirling2col) mixed: sin, cos, asin, atan, compose, composeInv, toFallingPowForm, fromFallingPowForm, valToVal prefixPowSum: 1^i + 2^i + \\cdots + (n - 1)^i, 0 < i < k sumFraction: \\sum_{i = 0}^{n - 1} a_i / (1 - b_i x) As an application, we compute n! O(\\sqrt{n} \\log^2 n) and O(\\sqrt{n} \\log n (introduced by min_25) in poly.hpp","title":"Method"},{"location":"math/poly/#example","text":"#include <bits/stdc++.h> #define clog(x) std::clog << (#x) << \" is \" << (x) << '\\n'; using LL = long long ; #include \"cpplib/math.hpp\" template < typename T > void debug ( std :: vector < T > a ){ for ( auto & i : a ) std :: cout << i << ' ' ; std :: cout << std :: endl ; } int main () { //freopen(\"in\", \"r\", stdin); std :: cin . tie ( nullptr ) -> sync_with_stdio ( false ); std :: vector < int > a { 1 , 2 , 3 , 4 }; std :: vector < int > b { 1 , 2 , 3 }; PolyS A1 ( a ), B1 ( b ); auto c1 = ( A1 * B1 ). a ; debug ( c1 ); using modM = MInt < 998244353 > ; PolyNTT A2 ( trans < modM > ( a )), B2 ( trans < modM > ( b )); auto c2 = ( A2 * B2 ). a ; debug ( c2 ); // you must setMod before using it ModInt :: setMod ( 998244353 ); PolyFFTDynamic A3 ( trans < ModInt > ( a )), B3 ( trans < ModInt > ( b )); auto c3 = ( A3 * B3 ). a ; debug ( c3 ); ModLL :: setMod ( 998244353 ); PolyMFT A4 ( trans < ModLL > ( a )), B4 ( trans < ModLL > ( b )); auto c4 = ( A4 * B4 ). a ; debug ( c4 ); return 0 ; }","title":"Example"},{"location":"math/primary/","text":"primary.hpp \u00b6 primary.hpp is the foundation of math.hpp mod.hpp \u00b6 There are three classes: MInt , ModInt , ModLL . Only MInt is a class template and template<typename valT> (occur in other place) will be one of them. You must init them a mod before use them. methods \u00b6 Elementary arithmetics: +, -, *, /, +=, -=, *=, /= C-style operator: ++, --, <<, <<= (There is no >> since ((a + M) \\text{>>} x) \\neq (a \\text{>>} x) in general) raw for constant-factor speedup. pow , >>, << are friend methods. inv is not based on pow , since M is not assume to be prime number. Example \u00b6 #include <bits/stdc++.h> #include \"cpplib/math/mod.hpp\" constexpr int M = 998244353 ; using mod = MInt < M > ; int main () { //freopen(\"in\", \"r\", stdin); std :: cin . tie ( nullptr ) -> sync_with_stdio ( false ); int a , b ; std :: cin >> a >> b ; mod a1 ( a ), b1 ( b ); std :: cout << a1 + b1 << '\\n' ; ModInt :: setMod ( M ); ModInt a2 ( a ), b2 ( b ); std :: cout << a2 - b2 << '\\n' ; ModLL :: setMod ( M ); ModInt a3 ( a ), b3 ( b ); std :: cout << a3 * b3 << '\\n' ; std :: cout << a3 / b3 << '\\n' ; return 0 ; } fft.hpp \u00b6 fast Fourier transform It contains dft and idft in namespace FFT . The size of a is a pow of 2 before you use dft(a) or idft(a) ntt.hpp \u00b6 number theory transform It contains dft and idft in template classs NTT . The template M should be NTT-friendly, and size of a is a pow of 2 less that 10^6 before you use dft(a) or idft(a) fmt.hpp \u00b6 fast Mobious transform basic.hpp \u00b6 \\text{powMod}(a, n, p) = a^n \\mod p \\text{floor}(a, n) = \\lfloor \\frac{a}{n} \\rfloor , \\text{ceil}(a, n) = \\lceil \\frac{a}{n} \\rceil int128: input and output gcd, exGcd crt2, crt Binom, BinomModp Lagrange \\displaystyle \\text{powSum}(n, k) = \\sum_{i = 0}^n i^k matrix multiplication(class template): you may use Matrix<MInt<998244353>> to defined a matrix quickSort (don't use it) \\text{MEX.solve}(x) = MEX_{a_i \\in S} (a_i \\oplus x) spf: smallest prime factor(foundmental important) trans: transform vector<int> to vector<valT> BerlekampMassey: find shortest recursive relational formula","title":"primary"},{"location":"math/primary/#primaryhpp","text":"primary.hpp is the foundation of math.hpp","title":"primary.hpp"},{"location":"math/primary/#modhpp","text":"There are three classes: MInt , ModInt , ModLL . Only MInt is a class template and template<typename valT> (occur in other place) will be one of them. You must init them a mod before use them.","title":"mod.hpp"},{"location":"math/primary/#methods","text":"Elementary arithmetics: +, -, *, /, +=, -=, *=, /= C-style operator: ++, --, <<, <<= (There is no >> since ((a + M) \\text{>>} x) \\neq (a \\text{>>} x) in general) raw for constant-factor speedup. pow , >>, << are friend methods. inv is not based on pow , since M is not assume to be prime number.","title":"methods"},{"location":"math/primary/#example","text":"#include <bits/stdc++.h> #include \"cpplib/math/mod.hpp\" constexpr int M = 998244353 ; using mod = MInt < M > ; int main () { //freopen(\"in\", \"r\", stdin); std :: cin . tie ( nullptr ) -> sync_with_stdio ( false ); int a , b ; std :: cin >> a >> b ; mod a1 ( a ), b1 ( b ); std :: cout << a1 + b1 << '\\n' ; ModInt :: setMod ( M ); ModInt a2 ( a ), b2 ( b ); std :: cout << a2 - b2 << '\\n' ; ModLL :: setMod ( M ); ModInt a3 ( a ), b3 ( b ); std :: cout << a3 * b3 << '\\n' ; std :: cout << a3 / b3 << '\\n' ; return 0 ; }","title":"Example"},{"location":"math/primary/#ffthpp","text":"fast Fourier transform It contains dft and idft in namespace FFT . The size of a is a pow of 2 before you use dft(a) or idft(a)","title":"fft.hpp"},{"location":"math/primary/#ntthpp","text":"number theory transform It contains dft and idft in template classs NTT . The template M should be NTT-friendly, and size of a is a pow of 2 less that 10^6 before you use dft(a) or idft(a)","title":"ntt.hpp"},{"location":"math/primary/#fmthpp","text":"fast Mobious transform","title":"fmt.hpp"},{"location":"math/primary/#basichpp","text":"\\text{powMod}(a, n, p) = a^n \\mod p \\text{floor}(a, n) = \\lfloor \\frac{a}{n} \\rfloor , \\text{ceil}(a, n) = \\lceil \\frac{a}{n} \\rceil int128: input and output gcd, exGcd crt2, crt Binom, BinomModp Lagrange \\displaystyle \\text{powSum}(n, k) = \\sum_{i = 0}^n i^k matrix multiplication(class template): you may use Matrix<MInt<998244353>> to defined a matrix quickSort (don't use it) \\text{MEX.solve}(x) = MEX_{a_i \\in S} (a_i \\oplus x) spf: smallest prime factor(foundmental important) trans: transform vector<int> to vector<valT> BerlekampMassey: find shortest recursive relational formula","title":"basic.hpp"}]}